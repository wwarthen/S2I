0001   0000             ;__________________________________________________________________________________________________
0002   0000             ;
0003   0000             ;	HBIOS CONTAINER FOR SCSI2IDE
0004   0000             ; 	ASSUMES IT WILL BE LOCATED AT $F000-$FFFF
0005   0000             ;__________________________________________________________________________________________________
0006   0000             ;
0007   F000             	.ORG	$F000
0008   F000             ;
0009   F000             ; INCLUDE GENERIC STUFF
0010   F000             ;
0011   F000             #INCLUDE "std.asm"
0001+  F000             ; ~/RomWBW/branches/s100/Source/std.asm 1/19/2013 dwg - 
0002+  F000             ;
0003+  F000             
0004+  F000             ; The purpose of this file is to define generic symbols and to include
0005+  F000             ; the appropriate std-*.inc file to bring in platform specifics.
0006+  F000             
0007+  F000             ; There are four classes of systems supported by N8VEM.
0008+  F000             ; 1. N8VEM 	Platforms that include ECB interface
0009+  F000             ; 2. ZETA	Genrally N8VEM-like, but no ECB
0010+  F000             ; 3. N8		Generally N8VEM-like bt 180 and extra embedded devices
0011+  F000             ; 4. S100	Assumes Z80 Master CPU Card
0012+  F000             
0013+  F000             ; All the classes require certain generic definitions, and these are
0014+  F000             ; defined here prior to the inclusion of platform specific .inc files.
0015+  F000             
0016+  F000             ; It is unfortunate, but all the possible config items must be defined
0017+  F000             ; here because the config gets read before the specific std-*.inc's
0018+  F000             
0019+  F000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0020+  F000             ;
0021+  F000             TRUE		.EQU 	1
0022+  F000             FALSE		.EQU 	0
0023+  F000             ;
0024+  F000             ; DEPRECATED STUFF!!!
0025+  F000             ;
0026+  F000             DIOPLT		.EQU	0		; DEPRECATED!!!
0027+  F000             VDUMODE		.EQU	0		; DEPRECATED!!!
0028+  F000             BIOSSIZE	.EQU	0100H		; DEPRECATED!!!
0029+  F000             ;
0030+  F000             ; PRIMARY HARDWARE PLATFORMS
0031+  F000             ;
0032+  F000             PLT_N8VEM	.EQU	1		; N8VEM ECB Z80 SBC
0033+  F000             PLT_ZETA	.EQU	2		; ZETA Z80 SBC
0034+  F000             PLT_N8		.EQU	3		; N8 (HOME COMPUTER) Z180 SBC
0035+  F000             PLT_S2I		.EQU	4		; SCSI2IDE
0036+  F000             PLT_S100	.EQU	5		; S100COMPUTERS Z80 based system
0037+  F000             ;
0038+  F000             ; BOOT STYLE
0039+  F000             ;
0040+  F000             BT_MENU		.EQU	1	; WAIT FOR MENU SELECTION AT LOADER PROMPT
0041+  F000             BT_AUTO		.EQU	2	; AUTO SELECT BOOT_DEFAULT AFTER BOOT_TIMEOUT
0042+  F000             ;
0043+  F000             ; RAM DISK INITIALIZATION OPTIONS
0044+  F000             ;
0045+  F000             CLR_NEVER	.EQU	0		; NEVER CLEAR RAM DISK
0046+  F000             CLR_AUTO	.EQU	1		; CLEAR RAM DISK IF INVALID DIR ENTRIES
0047+  F000             CLR_ALWAYS	.EQU	2		; ALWAYS CLEAR RAM DISK
0048+  F000             ;
0049+  F000             ; DISK MAP SELECTION OPTIONS
0050+  F000             ;
0051+  F000             DM_ROM		.EQU	1		; ROM DRIVE PRIORITY
0052+  F000             DM_RAM		.EQU	2		; RAM DRIVE PRIORITY
0053+  F000             DM_FD		.EQU	3		; FLOPPY DRIVE PRIORITY
0054+  F000             DM_IDE		.EQU	4		; IDE DRIVE PRIORITY
0055+  F000             DM_PPIDE	.EQU	5		; PPIDE DRIVE PRIORITY
0056+  F000             DM_SD		.EQU	6		; SD DRIVE PRIORITY
0057+  F000             DM_PRPSD	.EQU	7		; PROPIO SD DRIVE PRIORITY
0058+  F000             DM_PPPSD	.EQU	8		; PROPIO SD DRIVE PRIORITY
0059+  F000             DM_HDSK		.EQU	9		; SIMH HARD DISK DRIVE PRIORITY
0060+  F000             ;
0061+  F000             ; FLOPPY DISK MEDIA SELECTIONS (ID'S MUST BE INDEX OF ENTRY IN FCD_TBL)
0062+  F000             ;
0063+  F000             FDM720		.EQU	0		; 3.5" FLOPPY, 720KB, 2 SIDES, 80 TRKS, 9 SECTORS
0064+  F000             FDM144		.EQU	1		; 3.5" FLOPPY, 1.44MB, 2 SIDES, 80 TRKS, 18 SECTORS
0065+  F000             FDM360		.EQU	2		; 5.25" FLOPPY, 360KB, 2 SIDES, 40 TRKS, 9 SECTORS
0066+  F000             FDM120		.EQU	3		; 5.25" FLOPPY, 1.2MB, 2 SIDES, 80 TRKS, 15 SECTORS
0067+  F000             FDM111		.EQU	4		; 8" FLOPPY, 1.11MB, 2 SIDES, 74 TRKS, 15 SECTORS
0068+  F000             ;
0069+  F000             ; MEDIA ID VALUES
0070+  F000             ;
0071+  F000             MID_NONE	.EQU	0
0072+  F000             MID_MDROM	.EQU	1
0073+  F000             MID_MDRAM	.EQU	2
0074+  F000             MID_HD		.EQU	3
0075+  F000             MID_FD720	.EQU	4
0076+  F000             MID_FD144	.EQU	5
0077+  F000             MID_FD360	.EQU	6
0078+  F000             MID_FD120	.EQU	7
0079+  F000             MID_FD111	.EQU	8
0080+  F000             ;
0081+  F000             ; FD MODE SELECTIONS
0082+  F000             ;
0083+  F000             FDMODE_NONE	.equ	0		; FD modes defined in std-*.inc
0084+  F000             FDMODE_DIO	.EQU	1		; DISKIO V1
0085+  F000             FDMODE_ZETA	.EQU	2		; ZETA
0086+  F000             FDMODE_DIDE	.EQU	3		; DUAL IDE
0087+  F000             FDMODE_N8	.EQU	4		; N8
0088+  F000             FDMODE_DIO3	.EQU	5		; DISKIO V3
0089+  F000             ;
0090+  F000             ; IDE MODE SELECTIONS
0091+  F000             ;
0092+  F000             IDEMODE_NONE	.EQU	0
0093+  F000             IDEMODE_DIO	.EQU	1		; DISKIO V1
0094+  F000             IDEMODE_DIDE	.EQU	2		; DUAL IDE
0095+  F000             ;
0096+  F000             ; PPIDE MODE SELECTIONS
0097+  F000             ;
0098+  F000             PPIDEMODE_NONE	.EQU	0
0099+  F000             PPIDEMODE_STD	.EQU	1		; STANDARD N8VEM PARALLEL PORT
0100+  F000             PPIDEMODE_DIO3	.EQU	2		; DISKIO V3 PARALLEL PORT
0101+  F000             ;
0102+  F000             ; SD MODE SELECTIONS
0103+  F000             ;
0104+  F000             SDMODE_NONE	.EQU	0
0105+  F000             SDMODE_JUHA	.EQU	1		; JUHA MINI BOARD
0106+  F000             SDMODE_N8	.EQU	2		; N8-2511, UNMODIFIED
0107+  F000             SDMODE_CSIO	.EQU	3		; N8-2312 OR N8-2511 MODIFIED
0108+  F000             SDMODE_PPI	.EQU	4		; PPISD MINI BOARD
0109+  F000             SDMODE_UART	.EQU	5		; S2ISD
0110+  F000             SDMODE_DSD	.EQU	6		; DUAL SD
0111+  F000             SDMODE_MK4	.EQU	7		; MARK IV
0112+  F000             ;
0113+  F000             ; CONSOLE TERMINAL TYPE CHOICES
0114+  F000             ;
0115+  F000             TERM_TTY	.EQU	0
0116+  F000             TERM_ANSI	.EQU	1
0117+  F000             TERM_WYSE	.EQU	2
0118+  F000             TERM_VT52	.EQU	3
0119+  F000             ;
0120+  F000             ; EMULATION TYPES
0121+  F000             ;
0122+  F000             EMUTYP_NONE	.EQU	0
0123+  F000             EMUTYP_TTY	.EQU	1
0124+  F000             EMUTYP_ANSI	.EQU	2
0125+  F000             ;
0126+  F000             ; SCSI DEVICE PERSONALITY CHOICES
0127+  F000             ;
0128+  F000             S2I_PER_N8VEM	.EQU	1
0129+  F000             S2I_PER_ST125N	.EQU	2
0130+  F000             ;
0131+  F000             ; SYSTEM GENERATION SETTINGS
0132+  F000             ;
0133+  F000             SYS_CPM		.EQU	1		; CPM (IMPLIES BDOS + CCP)
0134+  F000             SYS_ZSYS	.EQU	2		; ZSYSTEM OS (IMPLIES ZSDOS + ZCPR)
0135+  F000             ;
0136+  F000             DOS_BDOS	.EQU	1		; BDOS
0137+  F000             DOS_ZDDOS	.EQU	2		; ZDDOS VARIANT OF ZSDOS
0138+  F000             DOS_ZSDOS	.EQU	3		; ZSDOS
0139+  F000             ;
0140+  F000             CP_CCP		.EQU	1		; CCP COMMAND PROCESSOR
0141+  F000             CP_ZCPR		.EQU	2		; ZCPR COMMAND PROCESSOR
0142+  F000             ;
0143+  F000             ; CONFIGURE DOS (DOS) AND COMMAND PROCESSOR (CP) BASED ON SYSTEM SETTING (SYS)
0144+  F000             ;
0145+  F000             #IFNDEF BLD_SYS
0146+  F000             SYS		.EQU	SYS_CPM
0147+  F000~            #ELSE
0148+  F000~            SYS		.EQU	BLD_SYS
0149+  F000             #ENDIF
0150+  F000             ;
0151+  F000             #IF (SYS == SYS_CPM)
0152+  F000             DOS		.EQU	DOS_BDOS
0153+  F000             CP		.EQU	CP_CCP
0154+  F000             #DEFINE		OSLBL	"CP/M-80 2.2"
0155+  F000             #ENDIF
0156+  F000             ;
0157+  F000~            #IF (SYS == SYS_ZSYS)
0158+  F000~            DOS		.EQU	DOS_ZSDOS
0159+  F000~            CP		.EQU	CP_ZCPR
0160+  F000~            #DEFINE		OSLBL	"ZSDOS 1.1"
0161+  F000             #ENDIF
0162+  F000             ;
0163+  F000             ; INCLUDE VERSION AND BUILD SETTINGS
0164+  F000             ;
0165+  F000             #INCLUDE "ver.inc"			; ADD BIOSVER
0001++ F000             #DEFINE	RMJ	2
0002++ F000             #DEFINE	RMN	2
0003++ F000             #DEFINE	RUP	0
0004++ F000             #DEFINE	RTP	3
0005++ F000             #DEFINE BIOSVER	"2.2 B3"
0006++ F000             #DEFINE REVISION 1741
0166+  F000             ;
0167+  F000             #INCLUDE "build.inc"			; INCLUDE USER CONFIG, ADD VARIANT, TIMESTAMP, & ROMSIZE
0001++ F000             ; RomWBW Configured for S2I 1gx2, 04/02/2021 19:23:08
0002++ F000             ;
0003++ F000             #DEFINE		TIMESTAMP	"210402T0723"
0004++ F000             #DEFINE		VARIANT		"S2I-Wayne"
0005++ F000             ;
0006++ F000             ROMSIZE		.EQU		32		; SIZE OF ROM IN KB
0007++ F000             PLATFORM	.EQU		PLT_S2I		; HARDWARE PLATFORM
0008++ F000             ;
0009++ F000             ; INCLUDE PLATFORM SPECIFIC DEVICE DEFINITIONS
0010++ F000             ;
0011++ F000~            #IF (PLATFORM == PLT_S100)
0012++ F000~              #INCLUDE "std-s100.inc"
0013++ F000             #ELSE
0014++ F000               #INCLUDE "std-n8vem.inc"
0001+++F000             ;
0002+++F000             ; CHARACTER DEVICES
0003+++F000             ;
0004+++F000             CIODEV_UART	.EQU	$00
0005+++F000             CIODEV_ASCI	.EQU	$10
0006+++F000             CIODEV_VDU	.EQU	$20
0007+++F000             CIODEV_CVDU	.EQU	$30
0008+++F000             CIODEV_UPD7220	.EQU	$40
0009+++F000             CIODEV_N8V	.EQU	$50
0010+++F000             CIODEV_PRPCON	.EQU	$60
0011+++F000             CIODEV_PPPCON	.EQU	$70
0012+++F000             CIODEV_CRT	.EQU	$D0
0013+++F000             CIODEV_BAT	.EQU	$E0
0014+++F000             CIODEV_NUL	.EQU	$F0
0015+++F000             ;
0016+++F000             ; DISK DEVICES (ONLY FIRST NIBBLE RELEVANT, SECOND NIBBLE RESERVED FOR UNIT)
0017+++F000             ;
0018+++F000             DIODEV_MD	.EQU	$00
0019+++F000             DIODEV_FD	.EQU	$10
0020+++F000             DIODEV_IDE	.EQU	$20
0021+++F000             DIODEV_ATAPI	.EQU	$30
0022+++F000             DIODEV_PPIDE	.EQU	$40
0023+++F000             DIODEV_SD	.EQU	$50
0024+++F000             DIODEV_PRPSD	.EQU	$60
0025+++F000             DIODEV_PPPSD	.EQU	$70
0026+++F000             DIODEV_HDSK	.EQU	$80
0027+++F000             ;
0028+++F000             ; VDA DEVICES (VIDEO DISPLAY ADAPTER)
0029+++F000             ;
0030+++F000             VDADEV_NONE	.EQU	$00		; NO VDA DEVICE
0031+++F000             VDADEV_VDU	.EQU	$10		; ECB VDU - 6545 CHIP
0032+++F000             VDADEV_CVDU	.EQU	$20		; ECB COLOR VDU - 8563 CHIP (NOT IMP)
0033+++F000             VDADEV_UPD7220	.EQU	$30		; ECB uP7220 (NOT IMPLEMENTED)
0034+++F000             VDADEV_N8V	.EQU	$40		; N8 ONBOARD VDA SUBSYSTEM
0015++ F000             #ENDIF
0016++ F000             ;
0017++ F000             #INCLUDE "config_S2I_1gx2.asm"
0001+++F000             ;
0002+++F000             ;==================================================================================================
0003+++F000             ;   ROMWBW 2.X CONFIGURATION FOR SCSI2IDE 11/26/2012
0004+++F000             ;==================================================================================================
0005+++F000             ;
0006+++F000             ; BUILD CONFIGURATION OPTIONS
0007+++F000             ;
0008+++F000             CPUFREQ		.EQU	8		; IN MHZ, USED TO COMPUTE DELAY FACTORS
0009+++F000             RAMSIZE		.EQU	32		; SIZE OF RAM IN KB, MUST MATCH YOUR HARDWARE!!!
0010+++F000             ;
0011+++F000             DEFCON		.EQU	CIODEV_UART	; DEFAULT CONSOLE DEVICE (LOADER AND MONITOR): CIODEV_UART, CIODEV_VDU, DIODEV_PRPCON
0012+++F000             ;
0013+++F000             BAUDRATE	.EQU	38400		; IN BPS: 1200, 9600, 38400, ..., 115200
0014+++F000             ;
0015+++F000             S2I_TRACE	.EQU	2		; 0=SILENT, 1=ERRORS, 2=EVERYTHING (DEBUG)
0016+++F000             S2I_PER		.EQU	S2I_PER_N8VEM	; PERSONALITY (N8VEM, ST125N)
0017+++F000             S2I_PDMA	.EQU	TRUE		; PSEUDO DMA (TRUE, FALSE)
0018+++F000             S2I_LUNCNT	.EQU	2		; NUMBER OF LUNS (1-7)
0019+++F000             S2I_LUNSIZ	.EQU	1024		; SIZE OF EACH LUN (IN MB)
0020+++F000             ;
0021+++F000             UARTENABLE	.EQU	TRUE		; TRUE FOR UART SUPPORT (ALMOST ALWAYS WANT THIS TO BE TRUE)
0022+++F000             UARTFIFO	.EQU	TRUE		; TRUE ENABLES UART FIFO (16550 ASSUMED, N8VEM AND ZETA ONLY)
0023+++F000             UARTAFC		.EQU	FALSE		; TRUE ENABLES AUTO FLOW CONTROL (YOUR TERMINAL/UART MUST SUPPORT RTS/CTS FLOW CONTROL!!!)
0024+++F000             ;
0025+++F000             PPIDEENABLE	.EQU	TRUE		; TRUE FOR PPIDE SUPPORT (DO NOT COMBINE WITH DSKYENABLE)
0026+++F000             PPIDEIOB	.EQU	$80		; PPIDE IOBASE
0027+++F000             PPIDETRACE	.EQU	1		; 0=SILENT, 1=ERRORS, 2=EVERYTHING (ONLY RELEVANT IF PPIDEENABLE = TRUE)
0028+++F000             PPIDE8BIT	.EQU	FALSE		; USE IDE 8BIT TRANSFERS (PROBABLY ONLY WORKS FOR CF CARDS!)
0029+++F000             PPIDECAPACITY	.EQU	64		; CAPACITY OF DEVICE (IN MB)
0030+++F000             PPIDESLOW	.EQU	FALSE		; ADD DELAYS TO HELP PROBLEMATIC HARDWARE (TRY THIS IF PPIDE IS UNRELIABLE)
0031+++F000             ;
0032+++F000             DSKYENABLE	.EQU	FALSE		; TRUE FOR DSKY SUPPORT (DO NOT COMBINE WITH PPIDE)
0033+++F000             ;
0034+++F000             SDENABLE	.EQU	TRUE		; TRUE FOR SD SUPPORT
0035+++F000             SDMODE		.EQU	SDMODE_UART	; SDMODE_JUHA, SDMODE_CSIO, SDMODE_UART, SDMODE_PPI, SDMODE_DSD
0036+++F000             SDTRACE		.EQU	1		; 0=SILENT, 1=ERRORS, 2=EVERYTHING (ONLY RELEVANT IF IDEENABLE = TRUE)
0037+++F000             SDCAPACITY	.EQU	64		; CAPACITY OF DEVICE (IN MB)
0038+++F000             SDCSIOFAST	.EQU	FALSE		; TABLE-DRIVEN BIT INVERTER
0039+++F000             ;
0040+++F000             VDUENABLE	.EQU	FALSE		; TRUE FOR VDU BOARD SUPPORT
0041+++F000             CVDUENABLE	.EQU	FALSE		; TRUE FOR CVDU BOARD SUPPORT
0042+++F000             UPD7220ENABLE	.EQU	FALSE		; TRUE FOR uPD7220 BOARD SUPPORT
0043+++F000             N8VENABLE	.EQU	FALSE		; TRUE FOR N8 (TMS9918) VIDEO/KBD SUPPORT
0044+++F000             FDENABLE	.EQU	FALSE		; TRUE FOR FLOPPY SUPPORT
0045+++F000             IDEENABLE	.EQU	FALSE		; TRUE FOR IDE SUPPORT
0046+++F000             PRPENABLE	.EQU	FALSE		; TRUE FOR PROPIO SD SUPPORT (FOR N8VEM PROPIO ONLY!)
0047+++F000             PPPENABLE	.EQU	FALSE		; TRUE FOR PARPORTPROP SUPPORT
0048+++F000             HDSKENABLE	.EQU	FALSE		; TRUE FOR SIMH HDSK SUPPORT
0018++ F000             ;
0168+  F000             ;
0169+  F000             ; INCLUDE PLATFORM SPECIFIC HARDWARE DEFINITIONS
0170+  F000             ;
0171+  F000~            #IF ((PLATFORM == PLT_N8VEM) | (PLATFORM == PLT_ZETA))
0172+  F000~            #INCLUDE "n8vem.inc"
0173+  F000             #ENDIF
0174+  F000             ;
0175+  F000             #IF (PLATFORM == PLT_S2I)
0176+  F000             #INCLUDE "s2i.inc"
0001++ F000             ;
0002++ F000             ; N8VEM HARDWARE IO PORT ADDRESSES AND MEMORY LOCATIONS
0003++ F000             ;
0004++ F000             MPCL_RAM	.EQU 	78H		; BASE IO ADDRESS OF RAM MEMORY PAGER CONFIGURATION LATCH
0005++ F000             MPCL_ROM	.EQU 	7CH		; BASE IO ADDRESS OF ROM MEMORY PAGER CONFIGURATION LATCH
0006++ F000             RTC		.EQU	70H		; ADDRESS OF RTC LATCH AND INPUT PORT
0007++ F000             ;
0008++ F000             ; PPI 82C55 I/O IS DECODED TO PORT 60-67
0009++ F000             ;
0010++ F000             PPIBASE		.EQU	80H
0011++ F000             PPIA		.EQU 	PPIBASE + 0	; PORT A
0012++ F000             PPIB		.EQU 	PPIBASE + 1	; PORT B
0013++ F000             PPIC		.EQU 	PPIBASE + 2	; PORT C
0014++ F000             PPIX	 	.EQU 	PPIBASE + 3	; PPI CONTROL PORT
0015++ F000             ;
0016++ F000             ; 16C550 SERIAL LINE UART
0017++ F000             ;
0018++ F000             SIO_BASE	.EQU	90H
0019++ F000             SIO_RBR		.EQU	SIO_BASE + 0	; DLAB=0: RCVR BUFFER REG (READ ONLY)
0020++ F000             SIO_THR		.EQU	SIO_BASE + 0	; DLAB=0: XMIT HOLDING REG (WRITE ONLY)
0021++ F000             SIO_IER		.EQU	SIO_BASE + 1	; DLAB=0: INT ENABLE REG
0022++ F000             SIO_IIR		.EQU	SIO_BASE + 2	; INT IDENT REGISTER (READ ONLY)
0023++ F000             SIO_FCR		.EQU	SIO_BASE + 2	; FIFO CONTROL REG (WRITE ONLY)
0024++ F000             SIO_LCR		.EQU	SIO_BASE + 3	; LINE CONTROL REG
0025++ F000             SIO_MCR		.EQU	SIO_BASE + 4	; MODEM CONTROL REG
0026++ F000             SIO_LSR		.EQU	SIO_BASE + 5	; LINE STATUS REG
0027++ F000             SIO_MSR		.EQU	SIO_BASE + 6	; MODEM STATUS REG
0028++ F000             SIO_SCR		.EQU	SIO_BASE + 7	; SCRATCH REGISTER
0029++ F000             SIO_DLL		.EQU	SIO_BASE + 0	; DLAB=1: DIVISOR LATCH (LS)
0030++ F000             SIO_DLM		.EQU	SIO_BASE + 1	; DLAB=1: DIVISOR LATCH (MS)
0177+  F000             #ENDIF
0178+  F000             ;
0179+  F000~            #IF (PLATFORM == PLT_N8)
0180+  F000~            #INCLUDE "n8.inc"
0181+  F000             #ENDIF
0182+  F000             ;
0183+  F000~            #IF (PLATFORM == PLT_S100)
0184+  F000~            ;
0185+  F000~            #DEFINE S100_IOB			; WBW: FORCED ON TO MAKE BUILD WORK!
0186+  F000~            ;
0187+  F000~            #IFDEF S100_CPU
0188+  F000~            #INCLUDE "S100CPU.INC"
0189+  F000~            #ENDIF
0190+  F000~            ;
0191+  F000~            #IFDEF S100_IOB
0192+  F000~            #INCLUDE "S100IOB.INC"
0193+  F000~            #ENDIF
0194+  F000~            ;
0195+  F000~            #IFDEF S100_RRF
0196+  F000~            #INCLUDE "S100RRF.INC"
0197+  F000~            #ENDIF
0198+  F000~            ;
0199+  F000~            #IFDEF S100_DIDE
0200+  F000~            #INCLUDE "S100DIDE.INC"
0201+  F000~            #ENDIF
0202+  F000~            ;
0203+  F000             #ENDIF
0204+  F000             ;
0205+  F000             ; CHARACTER DEVICE FUNCTIONS
0206+  F000             ;
0207+  F000             CF_INIT		.EQU	0
0208+  F000             CF_IN		.EQU	1
0209+  F000             CF_IST		.EQU	2
0210+  F000             CF_OUT		.EQU	3
0211+  F000             CF_OST		.EQU	4
0212+  F000             ;
0213+  F000             ; DISK OPERATIONS
0214+  F000             ;
0215+  F000             DOP_READ	.EQU	0		; READ OPERATION
0216+  F000             DOP_WRITE	.EQU	1		; WRITE OPERATION
0217+  F000             DOP_FORMAT	.EQU	2		; FORMAT OPERATION
0218+  F000             DOP_READID	.EQU	3		; READ ID OPERATION
0219+  F000             ;
0220+  F000             ; DISK DRIVER FUNCTIONS
0221+  F000             ;
0222+  F000             DF_READY	.EQU	1
0223+  F000             DF_SELECT	.EQU	2
0224+  F000             DF_READ		.EQU	3
0225+  F000             DF_WRITE	.EQU	4
0226+  F000             DF_FORMAT	.EQU	5
0227+  F000             ;
0228+  F000             ; BIOS FUNCTIONS
0229+  F000             ;
0230+  F000             BF_CIO		.EQU	$00
0231+  F000             BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
0232+  F000             BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
0233+  F000             BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
0234+  F000             BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
0235+  F000             BF_CIOCFG	.EQU	BF_CIO + 4	; CHARACTER I/O CONFIG
0236+  F000             ;
0237+  F000             BF_DIO		.EQU	$10
0238+  F000             BF_DIORD	.EQU	BF_DIO + 0	; DISK READ
0239+  F000             BF_DIOWR	.EQU	BF_DIO + 1	; DISK WRITE
0240+  F000             BF_DIOST	.EQU	BF_DIO + 2	; DISK STATUS
0241+  F000             BF_DIOMED	.EQU	BF_DIO + 3	; DISK MEDIA
0242+  F000             BF_DIOID	.EQU	BF_DIO + 4	; DISK IDENTIFY
0243+  F000             BF_DIOGETBUF	.EQU	BF_DIO + 8	; DISK GET BUFFER ADR
0244+  F000             BF_DIOSETBUF	.EQU	BF_DIO + 9	; DISK SET BUFFER ADR
0245+  F000             ;
0246+  F000             BF_RTC		.EQU	$20
0247+  F000             BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
0248+  F000             BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
0249+  F000             BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
0250+  F000             BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
0251+  F000             BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
0252+  F000             BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
0253+  F000             ;
0254+  F000             BF_EMU		.EQU	$30
0255+  F000             BF_EMUIN	.EQU	BF_EMU + 0	; EMULATOR CHARACTER INPUT
0256+  F000             BF_EMUOUT	.EQU	BF_EMU + 1	; EMULATOR CHARACTER OUTPUT
0257+  F000             BF_EMUIST	.EQU	BF_EMU + 2	; EMULATOR CHARACTER INPUT STATUS
0258+  F000             BF_EMUOST	.EQU	BF_EMU + 3	; EMULATOR CHARACTER OUTPUT STATUS
0259+  F000             BF_EMUCFG	.EQU	BF_EMU + 4	; EMULATOR CHARACTER I/O CONFIG
0260+  F000             BF_EMUINI	.EQU	BF_EMU + 8	; INITIALIZE EMULATION
0261+  F000             BF_EMUQRY	.EQU	BF_EMU + 9	; QUERY EMULATION STATUS
0262+  F000             ;
0263+  F000             BF_VDA		.EQU	$40
0264+  F000             BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
0265+  F000             BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
0266+  F000             BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
0267+  F000             BF_VDASCS	.EQU	BF_VDA + 3	; SET CURSOR STYLE
0268+  F000             BF_VDASCP	.EQU	BF_VDA + 4	; SET CURSOR POSITION
0269+  F000             BF_VDASAT	.EQU	BF_VDA + 5	; SET CHARACTER ATTRIBUTE
0270+  F000             BF_VDASCO	.EQU	BF_VDA + 6	; SET CHARACTER COLOR
0271+  F000             BF_VDAWRC	.EQU	BF_VDA + 7	; WRITE CHARACTER
0272+  F000             BF_VDAFIL	.EQU	BF_VDA + 8	; FILL
0273+  F000             BF_VDASCR	.EQU	BF_VDA + 9	; SCROLL
0274+  F000             BF_VDAKST	.EQU	BF_VDA + 10	; GET KEYBOARD STATUS
0275+  F000             BF_VDAKFL	.EQU	BF_VDA + 11	; FLUSH KEYBOARD BUFFER
0276+  F000             BF_VDAKRD	.EQU	BF_VDA + 12	; READ KEYBOARD
0277+  F000             ;
0278+  F000             BF_SYS		.EQU	$F0
0279+  F000             BF_SYSGETCFG	.EQU	BF_SYS + 0	; GET CONFIGURATION DATA BLOCK
0280+  F000             BF_SYSSETCFG	.EQU	BF_SYS + 1	; SET CONFIGURATION DATA BLOCK
0281+  F000             BF_SYSBNKCPY	.EQU	BF_SYS + 2	; COPY TO/FROM RAM/ROM MEMORY BANK
0282+  F000             BF_SYSGETVER	.EQU	BF_SYS + 3	; GET VERSION OF HBIOS
0283+  F000             ;
0284+  F000             ; MEMORY LAYOUT
0285+  F000             ;
0286+  F000             CPM_LOC		.EQU	0D000H			; CONFIGURABLE: LOCATION OF CPM FOR RUNNING SYSTEM
0287+  F000             CPM_SIZ		.EQU	2F00H			; SIZE OF CPM IMAGE (CCP + BDOS + CBIOS (INCLUDING DATA))
0288+  F000             CPM_END		.EQU	CPM_LOC + CPM_SIZ
0289+  F000             ;
0290+  F000             CCP_LOC		.EQU	CPM_LOC			; START OF COMMAND PROCESSOR
0291+  F000             CCP_SIZ		.EQU	800H
0292+  F000             CCP_END		.EQU	CCP_LOC + CCP_SIZ
0293+  F000             ;
0294+  F000             BDOS_LOC	.EQU	CCP_END			; START OF BDOS
0295+  F000             BDOS_SIZ	.EQU	0E00H
0296+  F000             BDOS_END	.EQU	BDOS_LOC + BDOS_SIZ
0297+  F000             ;
0298+  F000             CBIOS_LOC	.EQU	BDOS_END
0299+  F000             CBIOS_SIZ	.EQU	CPM_END - CBIOS_LOC
0300+  F000             CBIOS_END	.EQU	CBIOS_LOC + CBIOS_SIZ
0301+  F000             ;
0302+  F000             CPM_ENT		.EQU	CBIOS_LOC
0303+  F000             ;
0304+  F000             HB_LOC		.EQU	CPM_END
0305+  F000             HB_SIZ		.EQU	100H
0306+  F000             HB_END		.EQU	HB_LOC + HB_SIZ
0307+  F000             ;
0308+  F000             MON_LOC		.EQU	0C000H			; LOCATION OF MONITOR FOR RUNNING SYSTEM
0309+  F000             MON_SIZ		.EQU	01000H			; SIZE OF MONITOR BINARY IMAGE
0310+  F000             MON_END		.EQU	MON_LOC + MON_SIZ
0311+  F000             MON_DSKY	.EQU	MON_LOC			; MONITOR ENTRY (DSKY)
0312+  F000             MON_UART	.EQU	MON_LOC + 3		; MONITOR ENTRY (UART)
0313+  F000             ;
0314+  F000             CBIOS_BOOT	.EQU	CBIOS_LOC + 0
0315+  F000             CBIOS_WBOOT	.EQU	CBIOS_LOC + 3
0316+  F000             CBIOS_CONST	.EQU	CBIOS_LOC + 6
0317+  F000             CBIOS_CONIN	.EQU	CBIOS_LOC + 9
0318+  F000             CBIOS_CONOUT	.EQU	CBIOS_LOC + 12
0319+  F000             CBIOS_LIST	.EQU	CBIOS_LOC + 15
0320+  F000             CBIOS_PUNCH	.EQU	CBIOS_LOC + 18
0321+  F000             CBIOS_READER	.EQU	CBIOS_LOC + 21
0322+  F000             CBIOS_HOME	.EQU	CBIOS_LOC + 24
0323+  F000             CBIOS_SELDSK	.EQU	CBIOS_LOC + 27
0324+  F000             CBIOS_SETTRK	.EQU	CBIOS_LOC + 30
0325+  F000             CBIOS_SETSEC	.EQU	CBIOS_LOC + 33
0326+  F000             CBIOS_SETDMA	.EQU	CBIOS_LOC + 36
0327+  F000             CBIOS_READ	.EQU	CBIOS_LOC + 39
0328+  F000             CBIOS_WRITE	.EQU	CBIOS_LOC + 42
0329+  F000             CBIOS_LISTST	.EQU	CBIOS_LOC + 45
0330+  F000             CBIOS_SECTRN	.EQU	CBIOS_LOC + 48
0331+  F000             ;
0332+  F000             ; EXTENDED CBIOS FUNCTIONS
0333+  F000             ;
0334+  F000             CBIOS_BNKSEL	.EQU	CBIOS_LOC + 51
0335+  F000             CBIOS_GETDSK	.EQU	CBIOS_LOC + 54
0336+  F000             CBIOS_SETDSK	.EQU	CBIOS_LOC + 57
0337+  F000             CBIOS_GETINFO	.EQU	CBIOS_LOC + 60
0338+  F000             ;
0339+  F000             ; PLACEHOLDERS FOR FUTURE CBIOS EXTENSIONS
0340+  F000             ;
0341+  F000             CBIOS_RSVD1	.EQU	CBIOS_LOC + 63
0342+  F000             CBIOS_RSVD2	.EQU	CBIOS_LOC + 76
0343+  F000             CBIOS_RSVD3	.EQU	CBIOS_LOC + 69
0344+  F000             CBIOS_RSVD4	.EQU	CBIOS_LOC + 72
0345+  F000             ;
0346+  F000             CDISK:	 	.EQU 	00004H		; LOC IN PAGE 0 OF CURRENT DISK NUMBER 0=A,...,15=P
0347+  F000             IOBYTE:	 	.EQU 	00003H		; LOC IN PAGE 0 OF I/O DEFINITION BYTE.
0348+  F000             ;
0349+  F000             ; MEMORY CONFIGURATION
0350+  F000             ;
0351+  F000             MSIZE		.EQU	59		; CP/M VERSION MEMORY SIZE IN KILOBYTES
0352+  F000             ;
0353+  F000             ; "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
0354+  F000             ; THAN 16K (REFERRED TO AS "B" THROUGHOUT THE TEXT) 
0355+  F000             ;
0356+  F000             BIAS:	 	.EQU 	(MSIZE-20)*1024
0357+  F000             CCP:	 	.EQU 	3400H+BIAS	; BASE OF CCP
0358+  F000             BDOS:	 	.EQU 	CCP+806H	; BASE OF BDOS
0359+  F000             BIOS:	 	.EQU 	CCP+1600H	; BASE OF BIOS
0360+  F000             CCPSIZ:		.EQU	00800H
0361+  F000             ;
0362+  F000~            #IF (PLATFORM == PLT_N8VEM)
0363+  F000~              #DEFINE 	PLATFORM_NAME	"N8VEM Z80"
0364+  F000             #ENDIF
0365+  F000~            #IF (PLATFORM == PLT_ZETA)
0366+  F000~              #DEFINE 	PLATFORM_NAME	"ZETA Z80"
0367+  F000             #ENDIF
0368+  F000~            #IF (PLATFORM == PLT_N8)
0369+  F000~              #DEFINE 	PLATFORM_NAME	"N8 Z180"
0370+  F000             #ENDIF
0371+  F000             #IF (PLATFORM == PLT_S2I)
0372+  F000               #DEFINE 	PLATFORM_NAME	"SCSI2IDE Z80"
0373+  F000             #ENDIF
0374+  F000~            #IF (PLATFORM == PLT_S100)
0375+  F000~              #DEFINE	PLATFORM_NAME	"S100"
0376+  F000             #ENDIF
0377+  F000             ;
0378+  F000~            #IF (DSKYENABLE)
0379+  F000~              #DEFINE	DSKYLBL	", DSKY"
0380+  F000             #ELSE
0381+  F000               #DEFINE	DSKYLBL	""
0382+  F000             #ENDIF
0383+  F000             ;
0384+  F000~            #IF (VDUENABLE)
0385+  F000~              #DEFINE	VDULBL	", VDU"
0386+  F000             #ELSE
0387+  F000               #DEFINE	VDULBL	""
0388+  F000             #ENDIF
0389+  F000             ;
0390+  F000~            #IF (CVDUENABLE)
0391+  F000~              #DEFINE	CVDULBL	", CVDU"
0392+  F000             #ELSE
0393+  F000               #DEFINE	CVDULBL	""
0394+  F000             #ENDIF
0395+  F000             ;
0396+  F000~            #IF (UPD7220ENABLE)
0397+  F000~              #DEFINE	UPD7220LBL	", UPD7220"
0398+  F000             #ELSE
0399+  F000               #DEFINE	UPD7220LBL	""
0400+  F000             #ENDIF
0401+  F000             ;
0402+  F000~            #IF (N8VENABLE)
0403+  F000~              #DEFINE	N8VLBL	", N8V"
0404+  F000             #ELSE
0405+  F000               #DEFINE	N8VLBL	""
0406+  F000             #ENDIF
0407+  F000             ;
0408+  F000~            #IF (FDENABLE)
0409+  F000~              #IF (FDMAUTO)
0410+  F000~                  #DEFINE	FDLBL	", FLOPPY (AUTOSIZE)"
0411+  F000~              #ELSE
0412+  F000~                #IF (FDMEDIA == FDM720)
0413+  F000~                  #DEFINE	FDLBL	", FLOPPY (360KB)"
0414+  F000~                #ENDIF
0415+  F000~                #IF (FDMEDIA == FDM111)
0416+  F000~                  #DEFINE	FDLBL	", FLOPPY (1.11MB)"
0417+  F000~                #ENDIF
0418+  F000~              #ENDIF
0419+  F000             #ELSE
0420+  F000               #DEFINE	FDLBL	""
0421+  F000             #ENDIF
0422+  F000             ;
0423+  F000~            #IF (IDEENABLE)
0424+  F000~              #IF (IDEMODE == IDEMODE_DIO)
0425+  F000~                #DEFINE	IDELBL		", IDE (DISKIO)"
0426+  F000~              #ENDIF
0427+  F000~              #IF (IDEMODE == IDEMODE_DIDE)
0428+  F000~                #DEFINE	IDELBL		", IDE (DUAL IDE)"
0429+  F000~              #ENDIF
0430+  F000             #ELSE
0431+  F000               #DEFINE	IDELBL		""
0432+  F000             #ENDIF
0433+  F000             ;
0434+  F000             #IF (PPIDEENABLE)
0435+  F000                 #DEFINE	PPIDELBL	", PPIDE"
0436+  F000~            #ELSE
0437+  F000~              #DEFINE	PPIDELBL	""
0438+  F000             #ENDIF
0439+  F000             ;
0440+  F000             #IF (SDENABLE)
0441+  F000               #DEFINE	SDLBL		", SD CARD"
0442+  F000~            #ELSE
0443+  F000~              #DEFINE	SDLBL		""
0444+  F000             #ENDIF
0445+  F000             ;
0446+  F000~            #IF (IDEENABLE)
0447+  F000~              #DEFINE	IDELBL	", IDE"
0448+  F000             #ELSE
0449+  F000               #DEFINE	IDELBL	""
0450+  F000             #ENDIF
0451+  F000             ;
0452+  F000             #IF (PPIDEENABLE)
0453+  F000               #DEFINE	PPIDELBL	", PPIDE"
0454+  F000~            #ELSE
0455+  F000~              #DEFINE	PPIDELBL	""
0456+  F000             #ENDIF
0457+  F000             
0458+  F000             #IF (SDENABLE)
0459+  F000               #DEFINE	SDLBL		", SD CARD"
0460+  F000~            #ELSE
0461+  F000~              #DEFINE	SDLBL		""
0462+  F000             #ENDIF
0463+  F000             
0464+  F000~            #IF (HDSKENABLE)
0465+  F000~              #DEFINE	HDSKLBL		", SIMH DISK"
0466+  F000             #ELSE
0467+  F000               #DEFINE	HDSKLBL		""
0468+  F000             #ENDIF
0469+  F000             
0470+  F000~            #IF (PRPENABLE)
0471+  F000~              #IF (PRPCONENABLE & PRPSDENABLE)
0472+  F000~                #DEFINE	PRPLBL		", PROPIO (CONSOLE, SD CARD)"
0473+  F000~              #ENDIF
0474+  F000~              #IF (PRPCONENABLE & !PRPSDENABLE)
0475+  F000~                #DEFINE	PRPLBL		", PROPIO (CONSOLE)"
0476+  F000~              #ENDIF
0477+  F000~              #IF (!PRPCONENABLE & PRPSDENABLE)
0478+  F000~                #DEFINE	PRPLBL		", PROPIO (SD CARD)"
0479+  F000~              #ENDIF
0480+  F000~              #IF (!PRPCONENABLE & !PRPSDENABLE)
0481+  F000~                #DEFINE	PRPLBL		", PROPIO ()"
0482+  F000~              #ENDIF
0483+  F000             #ELSE
0484+  F000               #DEFINE	PRPLBL		""
0485+  F000             #ENDIF
0486+  F000             
0487+  F000~            #IF (PPPENABLE)
0488+  F000~              #IF (PPPCONENABLE & PPPSDENABLE)
0489+  F000~                #DEFINE	PPPLBL		", PARPORTPROP (CONSOLE, SD CARD)"
0490+  F000~              #ENDIF
0491+  F000~              #IF (PPPCONENABLE & !PPPSDENABLE)
0492+  F000~                #DEFINE	PPPLBL		", PARPORTPROP (CONSOLE)"
0493+  F000~              #ENDIF
0494+  F000~              #IF (!PPPCONENABLE & PPPSDENABLE)
0495+  F000~                #DEFINE	PPPLBL		", PARPORTPROP (SD CARD)"
0496+  F000~              #ENDIF
0497+  F000~              #IF (!PPPCONENABLE & !PPPSDENABLE)
0498+  F000~                #DEFINE	PPPLBL		", PARPORTPROP ()"
0499+  F000~              #ENDIF
0500+  F000             #ELSE
0501+  F000               #DEFINE	PPPLBL		""
0502+  F000             #ENDIF
0503+  F000             
0504+  F000~            #IFDEF (HISTENABLE)
0505+  F000~            	#DEFINE	HISTLBL		", HIST"
0506+  F000             #ELSE
0507+  F000             	#DEFINE	HISTLBL		""
0508+  F000             #ENDIF
0509+  F000             
0510+  F000             	.ECHO	"Configuration: "
0511+  F000             	.ECHO	PLATFORM_NAME
0512+  F000             	.ECHO	DSKYLBL
0513+  F000             	.ECHO	VDULBL
0514+  F000             	.ECHO	FDLBL
0515+  F000             	.ECHO	IDELBL
0516+  F000             	.ECHO	PPIDELBL
0517+  F000             	.ECHO	SDLBL
0518+  F000             	.ECHO	PRPLBL
0519+  F000             	.ECHO	PPPLBL
0520+  F000             	.ECHO	HISTLBL
0521+  F000             	.ECHO	"\n"
0522+  F000             ;
0523+  F000             ; HELPER MACROS
0524+  F000             ;
0525+  F000             #DEFINE	PRTC(C)	CALL PRTCH \ .DB C			; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0526+  F000             #DEFINE	PRTS(S)	CALL PRTSTRD \ .DB S			; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0527+  F000             #DEFINE	PRTX(X) CALL PRTSTRI \ .DW X			; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0528+  F000             ;
0529+  F000             #DEFINE	XIO_PRTC(C)	CALL XIO_PRTCH \ .DB C	; PRINT CHARACTER C TO CONSOLE - PRTC('X')
0530+  F000             #DEFINE	XIO_PRTS(S)	CALL XIO_PRTSTRD \ .DB S	; PRINT STRING S TO CONSOLE - PRTD("HELLO")
0531+  F000             #DEFINE	XIO_PRTX(X)	CALL XIO_PRTSTRI \ .DW X	; PRINT STRING AT ADDRESS X TO CONSOLE - PRTI(STR_HELLO)
0012   F000             ;
0013   F000             ;==================================================================================================
0014   F000             ;   SYSTEM INITIALIZATION
0015   F000             ;==================================================================================================
0016   F000             ;
0017   F000             ; AT THIS POINT, IT IS ASSUMED WE ARE OPERATING FROM RAM PAGE 1
0018   F000             ;
0019   F000             INITSYS:
0020   F000             ;
0021   F000             ; ANNOUNCE HBIOS
0022   F000             ;
0023   F000 CD 91 FB    	CALL	NEWLINE
0024   F003 CD 91 FB    	CALL	NEWLINE
0025   F006 CD B4 FB    	PRTX(STR_PLATFORM)
0025   F009 75 FD       
0026   F00B CD AC FB    	PRTS(" @ $")
0026   F00E 20 40 20 24 
0027   F012 21 08 00    	LD	HL,CPUFREQ
0028   F015 CD 00 FD    	CALL	PRTDEC
0029   F018 CD AC FB    	PRTS("MHz ROM=$")
0029   F01B 4D 48 7A 20 
0029   F01F 52 4F 4D 3D 
0029   F023 24 
0030   F024 21 20 00    	LD	HL,ROMSIZE
0031   F027 CD 00 FD    	CALL	PRTDEC
0032   F02A CD AC FB    	PRTS("KB RAM=$")
0032   F02D 4B 42 20 52 
0032   F031 41 4D 3D 24 
0033   F035 21 20 00    	LD	HL,RAMSIZE
0034   F038 CD 00 FD    	CALL	PRTDEC
0035   F03B CD AC FB    	PRTS("KB$")
0035   F03E 4B 42 24    
0036   F041             ;
0037   F041             ; DURING INITIALIZATION, CONSOLE IS UART!
0038   F041             ; POST-INITIALIZATION, WILL BE SWITCHED TO USER CONFIGURED CONSOLE
0039   F041             ;
0040   F041 3E 00       	LD	A,CIODEV_UART
0041   F043 32 42 FD    	LD	(CONDEV),A
0042   F046             ;
0043   F046             ; PERFORM DEVICE INITIALIZATION
0044   F046             ;
0045   F046 06 03       	LD	B,HB_INITTBLLEN
0046   F048 11 71 F0    	LD	DE,HB_INITTBL
0047   F04B             INITSYS2:
0048   F04B CD 91 FB    	CALL	NEWLINE
0049   F04E 1A          	LD	A,(DE)
0050   F04F 6F          	LD	L,A
0051   F050 13          	INC	DE
0052   F051 1A          	LD	A,(DE)
0053   F052 67          	LD	H,A
0054   F053 13          	INC	DE
0055   F054 D5          	PUSH	DE
0056   F055 C5          	PUSH	BC
0057   F056 CD D9 FC    	CALL	JPHL
0058   F059 C1          	POP	BC
0059   F05A D1          	POP	DE
0060   F05B 10 EE       	DJNZ	INITSYS2
0061   F05D             ;;
0062   F05D             ;; SET UP THE DEFAULT DISK BUFFER ADDRESS
0063   F05D             ;;
0064   F05D             ;	LD	HL,$8000	; DEFAULT DISK XFR BUF ADDRESS
0065   F05D             ;	LD	(DIOBUF),HL	; SAVE IT
0066   F05D             ;
0067   F05D             ; NOW SWITCH TO USER CONFIGURED CONSOLE
0068   F05D             ;
0069   F05D 3E 00       	LD	A,DEFCON
0070   F05F 32 42 FD    	LD	(CONDEV),A	; SET THE ACTIVE CONSOLE DEVICE
0071   F062             ;
0072   F062             ; DISPLAY THE POST-INITIALIZATION BANNER
0073   F062             ;
0074   F062 CD 91 FB    	CALL	NEWLINE
0075   F065 CD 91 FB    	CALL	NEWLINE
0076   F068 CD B4 FB    	PRTX(STR_BANNER)
0076   F06B 4B FD       
0077   F06D CD 91 FB    	CALL	NEWLINE
0078   F070             ;
0079   F070 C9          	RET
0080   F071             ;
0081   F071             ;==================================================================================================
0082   F071             ;   TABLE OF INITIALIZATION ENTRY POINTS
0083   F071             ;==================================================================================================
0084   F071             ;
0085   F071             HB_INITTBL:
0086   F071             #IF (UARTENABLE)
0087   F071 3A F1       	.DW	UART_INIT
0088   F073             #ENDIF
0089   F073             #IF (PPIDEENABLE)
0090   F073 E2 F1       	.DW	PPIDE_INIT
0091   F075             #ENDIF
0092   F075             #IF (SDENABLE)
0093   F075 19 F5       	.DW	SD_INIT
0094   F077             #ENDIF
0095   F077             ;
0096   F077             HB_INITTBLLEN	.EQU	(($ - HB_INITTBL) / 2)
0097   F077             ;
0098   F077             ;==================================================================================================
0099   F077             ;   IDLE
0100   F077             ;==================================================================================================
0101   F077             ;
0102   F077             ;__________________________________________________________________________________________________
0103   F077             ;
0104   F077             IDLE:
0105   F077 C9          	RET
0106   F078             ;
0107   F078             ;==================================================================================================
0108   F078             ;   BIOS FUNCTION DISPATCHER
0109   F078             ;==================================================================================================
0110   F078             ;
0111   F078             ; MAIN BIOS FUNCTION
0112   F078             ;   B: FUNCTION
0113   F078             ;__________________________________________________________________________________________________
0114   F078             ;
0115   F078             BIOS_DISPATCH:
0116   F078 78          	LD	A,B		; REQUESTED FUNCTION IS IN B
0117   F079 FE 10       	CP	BF_CIO + $10	; $00-$0F: CHARACTER I/O
0118   F07B 38 1D       	JR	C,CIO_DISPATCH
0119   F07D FE 20       	CP	BF_DIO + $10	; $10-$1F: DISK I/O
0120   F07F 38 24       	JR	C,DIO_DISPATCH
0121   F081 FE 30       	CP	BF_RTC + $10	; $20-$2F: REAL TIME CLOCK (RTC)
0122   F083 38 5C       	JR	C,RTC_DISPATCH
0123   F085 FE 40       	CP	BF_EMU + $10	; $30-$3F: EMULATION
0124   F087 DA E4 F0    	JP	C,EMU_DISPATCH
0125   F08A FE 50       	CP	BF_VDA + $10	; $40-$4F: VIDEO DISPLAY ADAPTER
0126   F08C DA E7 F0    	JP	C,VDA_DISPATCH
0127   F08F             	
0128   F08F FE F0       	CP	BF_SYS		; SKIP TO BF_SYS VALUE AT $F0
0129   F091 DC 23 FC    	CALL	C,PANIC		; PANIC IF LESS THAN BF_SYS
0130   F094 C3 EA F0    	JP	SYS_DISPATCH	; OTHERWISE SYS CALL
0131   F097 CD 23 FC    	CALL	PANIC		; THIS SHOULD NEVER BE REACHED
0132   F09A             ;
0133   F09A             ;==================================================================================================
0134   F09A             ;   CHARACTER I/O DEVICE DISPATCHER
0135   F09A             ;==================================================================================================
0136   F09A             ;
0137   F09A             ; ROUTE CALL TO SPECIFIED CHARACTER I/O DRIVER
0138   F09A             ;   B: FUNCTION
0139   F09A             ;   C: DEVICE/UNIT
0140   F09A             ;
0141   F09A             CIO_DISPATCH:
0142   F09A 79          	LD	A,C		; REQUESTED DEVICE/UNIT IS IN C
0143   F09B E6 F0       	AND	$F0		; ISOLATE THE DEVICE PORTION
0144   F09D             #IF (UARTENABLE)
0145   F09D FE 00       	CP	CIODEV_UART
0146   F09F CA 25 F1    	JP	Z,UART_DISPATCH
0147   F0A2             #ENDIF
0148   F0A2 CD 23 FC    	CALL	PANIC
0149   F0A5             ;
0150   F0A5             ;==================================================================================================
0151   F0A5             ;   DISK I/O DEVICE DISPATCHER
0152   F0A5             ;==================================================================================================
0153   F0A5             ;
0154   F0A5             ; ROUTE CALL TO SPECIFIED DISK I/O DRIVER
0155   F0A5             ;   B: FUNCTION
0156   F0A5             ;   C: DEVICE/UNIT
0157   F0A5             ;
0158   F0A5             DIO_DISPATCH:
0159   F0A5             	; GET THE REQUESTED FUNCTION TO SEE IF SPECIAL HANDLING
0160   F0A5             	; IS NEEDED
0161   F0A5 78          	LD	A,B
0162   F0A6             ;
0163   F0A6             	; DIO FUNCTIONS STARTING AT DIOGETBUF ARE COMMON FUNCTIONS
0164   F0A6             	; AND DO NOT DISPATCH TO DRIVERS (HANDLED GLOBALLY)
0165   F0A6 FE 18       	CP	BF_DIOGETBUF	; TEST FOR FIRST OF THE COMMON FUNCTIONS
0166   F0A8 30 1E       	JR	NC,DIO_COMMON	; IF >= DIOGETBUF HANDLE AS COMMON DIO FUNCTION
0167   F0AA             ;
0168   F0AA             	; HACK TO FILL IN HSTTRK AND HSTSEC
0169   F0AA             	; BUT ONLY FOR READ/WRITE FUNCTION CALLS
0170   F0AA             	; ULTIMATELY, HSTTRK AND HSTSEC ARE TO BE REMOVED
0171   F0AA FE 12       	CP	BF_DIOST		; BEYOND READ/WRITE FUNCTIONS ?
0172   F0AC 30 07       	JR	NC,DIO_DISPATCH1	; YES, BYPASS
0173   F0AE 22 45 FD    	LD	(HSTTRK),HL		; RECORD TRACK
0174   F0B1 ED 53 47 FD 	LD	(HSTSEC),DE		; RECORD SECTOR
0175   F0B5             ;
0176   F0B5             DIO_DISPATCH1:
0177   F0B5             	; START OF THE ACTUAL DRIVER DISPATCHING LOGIC
0178   F0B5 79          	LD	A,C		; GET REQUESTED DEVICE/UNIT FROM C
0179   F0B6 32 44 FD    	LD	(HSTDSK),A	; TEMP HACK TO FILL IN HSTDSK
0180   F0B9 E6 F0       	AND	$F0		; ISOLATE THE DEVICE PORTION
0181   F0BB             #IF (PPIDEENABLE)
0182   F0BB FE 40       	CP	DIODEV_PPIDE
0183   F0BD CA B9 F1    	JP	Z,PPIDE_DISPATCH
0184   F0C0             #ENDIF
0185   F0C0             #IF (SDENABLE)
0186   F0C0 FE 50       	CP	DIODEV_SD
0187   F0C2 CA F5 F4    	JP	Z,SD_DISPATCH
0188   F0C5             #ENDIF
0189   F0C5             ;
0190   F0C5 CD 23 FC    	CALL	PANIC
0191   F0C8             ;
0192   F0C8             ; HANDLE COMMON DISK FUNCTIONS (NOT DEVICE DRIVER SPECIFIC)
0193   F0C8             ;
0194   F0C8             DIO_COMMON:
0195   F0C8 D6 18       	SUB	BF_DIOGETBUF	; FUNCTION = DIOGETBUF?
0196   F0CA 28 06       	JR	Z,DIO_GETBUF	; YES, HANDLE IT
0197   F0CC 3D          	DEC	A		; FUNCTION = DIOSETBUF?
0198   F0CD 28 08       	JR	Z,DIO_SETBUF	; YES, HANDLE IT
0199   F0CF CD 23 FC    	CALL	PANIC		; INVALID FUNCTION SPECFIED
0200   F0D2             ;
0201   F0D2             ; DISK: GET BUFFER ADDRESS
0202   F0D2             ;
0203   F0D2             DIO_GETBUF:
0204   F0D2 2A 49 FD    	LD	HL,(DIOBUF)	; HL = DISK BUFFER ADDRESS
0205   F0D5 AF          	XOR	A		; SIGNALS SUCCESS
0206   F0D6 C9          	RET
0207   F0D7             ;
0208   F0D7             ; DISK: SET BUFFER ADDRESS
0209   F0D7             ;
0210   F0D7             DIO_SETBUF:
0211   F0D7 CB 7C       	BIT	7,H		; IS HIGH ORDER BIT SET?
0212   F0D9 CC 23 FC    	CALL	Z,PANIC		; IF NOT, ADR IS IN LOWER 32K, NOT ALLOWED!!!
0213   F0DC 22 49 FD    	LD	(DIOBUF),HL	; RECORD NEW DISK BUFFER ADDRESS
0214   F0DF AF          	XOR	A		; SIGNALS SUCCESS
0215   F0E0 C9          	RET
0216   F0E1             ;
0217   F0E1             ;==================================================================================================
0218   F0E1             ;   REAL TIME CLOCK DEVICE DISPATCHER
0219   F0E1             ;==================================================================================================
0220   F0E1             ;
0221   F0E1             ; ROUTE CALL TO REAL TIME CLOCK DRIVER (NOT YET IMPLEMENTED)
0222   F0E1             ;   B: FUNCTION
0223   F0E1             ;
0224   F0E1             RTC_DISPATCH:
0225   F0E1 CD 23 FC    	CALL	PANIC
0226   F0E4             ;
0227   F0E4             ;==================================================================================================
0228   F0E4             ;   EMULATION HANDLER DISPATCHER
0229   F0E4             ;==================================================================================================
0230   F0E4             ;
0231   F0E4             ; ROUTE CALL TO EMULATION HANDLER CURRENTLY ACTIVE
0232   F0E4             ;   B: FUNCTION
0233   F0E4             ;
0234   F0E4             EMU_DISPATCH:
0235   F0E4 CD 23 FC    	CALL	PANIC		; INVALID
0236   F0E7             ;
0237   F0E7             ;==================================================================================================
0238   F0E7             ;   VIDEO DISPLAY ADAPTER DEVICE DISPATCHER
0239   F0E7             ;==================================================================================================
0240   F0E7             ;
0241   F0E7             ; ROUTE CALL TO SPECIFIED VDA DEVICE DRIVER
0242   F0E7             ;   B: FUNCTION
0243   F0E7             ;   C: DEVICE/UNIT
0244   F0E7             ;
0245   F0E7             VDA_DISPATCH:
0246   F0E7 CD 23 FC    	CALL	PANIC
0247   F0EA             ;
0248   F0EA             ;==================================================================================================
0249   F0EA             ;   SYSTEM FUNCTION DISPATCHER
0250   F0EA             ;==================================================================================================
0251   F0EA             ;
0252   F0EA             ;   B: FUNCTION
0253   F0EA             ;
0254   F0EA             SYS_DISPATCH:
0255   F0EA 78          	LD	A,B		; GET REQUESTED FUNCTION
0256   F0EB E6 0F       	AND	$0F		; ISOLATE SUB-FUNCTION
0257   F0ED 28 0C       	JR	Z,SYS_GETCFG	; $F0
0258   F0EF 3D          	DEC	A
0259   F0F0 28 15       	JR	Z,SYS_SETCFG	; $F1
0260   F0F2 3D          	DEC	A
0261   F0F3 28 1F       	JR	Z,SYS_BNKCPY	; $F2
0262   F0F5 3D          	DEC	A
0263   F0F6 28 1F       	JR	Z,SYS_GETVER	; $F3
0264   F0F8 CD 23 FC    	CALL	PANIC		; INVALID
0265   F0FB             ;
0266   F0FB             ; GET ACTIVE CONFIGURATION
0267   F0FB             ;   DE: DESTINATION TO RECEIVE CONFIGURATION DATA BLOCK
0268   F0FB             ;       MUST BE IN UPPER 32K
0269   F0FB             ;
0270   F0FB             SYS_GETCFG:
0271   F0FB CD 23 FC    	CALL	PANIC
0272   F0FE 21 00 02    	LD	HL,$0200		; SETUP SOURCE OF CONFIG DATA
0273   F101 01 00 01    	LD	BC,$0100		; SIZE OF CONFIG DATA
0274   F104 ED B0       	LDIR				; COPY IT
0275   F106 C9          	RET
0276   F107             ;
0277   F107             ; SET ACTIVE CONFIGURATION
0278   F107             ;   DE: SOURCE OF NEW CONFIGURATION DATA BLOCK
0279   F107             ;       MUST BE IN UPPER 32K
0280   F107             ;
0281   F107             ;   HBIOS IS NOT REALLY SET UP TO DYNAMICALLY RECONFIGURE ITSELF!!!
0282   F107             ;   THIS FUNCTION IS NOT USEFUL YET.
0283   F107             ;
0284   F107             SYS_SETCFG:
0285   F107 CD 23 FC    	CALL	PANIC
0286   F10A 21 00 02    	LD	HL,$0200		; SETUP SOURCE OF CONFIG DATA
0287   F10D 01 00 01    	LD	BC,$0100
0288   F110 EB          	EX	DE,HL
0289   F111 ED B0       	LDIR
0290   F113 C9          	RET
0291   F114             ;
0292   F114             ; PERFORM A BANKED MEMORY COPY
0293   F114             ;   C: BANK TO SWAP INTO LOWER 32K PRIOR TO COPY OPERATION
0294   F114             ;   IX: COUNT OF BYTES TO COPY
0295   F114             ;   HL: SOURCE ADDRESS FOR COPY
0296   F114             ;   DE: DESTINATION ADDRESS FOR COPY
0297   F114             ;
0298   F114             SYS_BNKCPY:
0299   F114 CD 23 FC    	CALL	PANIC
0300   F117             ;
0301   F117             ; GET THE CURRENT HBIOS VERSION
0302   F117             ;   RETURNS VERSION IN DE AS BCD
0303   F117             ;     D: MAJOR VERION IN TOP 4 BITS, MINOR VERSION IN LOW 4 BITS
0304   F117             ;     E: UPDATE VERION IN TOP 4 BITS, PATCH VERSION IN LOW 4 BITS
0305   F117             ;
0306   F117             SYS_GETVER:
0307   F117 11 03 22    	LD	DE,0 | (RMJ<<12) | (RMN<<8) | (RUP<<4) | RTP
0308   F11A AF          	XOR	A
0309   F11B C9          	RET
0310   F11C             ;
0311   F11C             ;==================================================================================================
0312   F11C             ;   GLOBAL HBIOS FUNCTIONS
0313   F11C             ;==================================================================================================
0314   F11C             ;
0315   F11C             ; COMMON ROUTINE THAT IS CALLED BY CHARACTER IO DRIVERS WHEN
0316   F11C             ; AN IDLE CONDITION IS DETECTED (WAIT FOR INPUT/OUTPUT)
0317   F11C             ;
0318   F11C             CIO_IDLE:
0319   F11C 21 43 FD    	LD	HL,IDLECOUNT		; POINT TO IDLE COUNT
0320   F11F 35          	DEC	(HL)			; 256 TIMES?
0321   F120 CC 77 F0    	CALL	Z,IDLE			; RUN IDLE PROCESS EVERY 256 ITERATIONS
0322   F123 AF          	XOR	A			; SIGNAL NO CHAR READY
0323   F124 C9          	RET				; AND RETURN
0324   F125             ;
0325   F125             ;==================================================================================================
0326   F125             ;   DEVICE DRIVERS
0327   F125             ;==================================================================================================
0328   F125             ;
0329   F125             #IF (UARTENABLE)
0330   F125             ORG_UART	.EQU	$
0331   F125               #INCLUDE "uart.asm"
0001+  F125             ;
0002+  F125             ;==================================================================================================
0003+  F125             ; UART DRIVER (SERIAL PORT)
0004+  F125             ;==================================================================================================
0005+  F125             ;
0006+  F125             #IF (PLATFORM != PLT_N8)
0007+  F125             UART0_DIV	.EQU	(1843200 / (16 * BAUDRATE))
0008+  F125             #ENDIF
0009+  F125             ;
0010+  F125             ; CHARACTER DEVICE DRIVER ENTRY
0011+  F125             ;   A: RESULT (OUT), CF=ERR
0012+  F125             ;   B: FUNCTION (IN)
0013+  F125             ;   C: CHARACTER (IN/OUT)
0014+  F125             ;   E: DEVICE/UNIT (IN)
0015+  F125             ;
0016+  F125             ;
0017+  F125             UART_DISPATCH:
0018+  F125~            #IF (PLATFORM == PLT_N8)
0019+  F125~            	LD	A,C	; GET DEVICE/UNIT
0020+  F125~            	AND	$0F	; ISOLATE UNIT
0021+  F125~            	JP	Z,UART0
0022+  F125~            	DEC	A
0023+  F125~            	JP	Z,UART1
0024+  F125~            	CALL	PANIC
0025+  F125             #ENDIF
0026+  F125             ;
0027+  F125             UART0:
0028+  F125 78          	LD	A,B	; GET REQUESTED FUNCTION
0029+  F126 E6 0F       	AND	$0F	; ISOLATE SUB-FUNCTION
0030+  F128 CA 8F F1    	JP	Z,UART0_IN
0031+  F12B 3D          	DEC	A
0032+  F12C CA A3 F1    	JP	Z,UART0_OUT
0033+  F12F 3D          	DEC	A
0034+  F130 CA 99 F1    	JP	Z,UART0_IST
0035+  F133 3D          	DEC	A
0036+  F134 CA AD F1    	JP	Z,UART0_OST
0037+  F137 CD 23 FC    	CALL	PANIC
0038+  F13A             ;
0039+  F13A             ;
0040+  F13A             ;
0041+  F13A             UART_INIT:
0042+  F13A~            #IF (PLATFORM == PLT_N8)
0043+  F13A~            	; ASCI0
0044+  F13A~            	PRTS("ASCI0: IO=0x$")
0044+  F13A~            	PRTS("ASCI0: IO=0x$")
0045+  F13A~            	LD	A,CPU_TDR0
0046+  F13A~            	CALL	PRTHEXBYTE
0047+  F13A~            	CALL	PC_COMMA
0048+  F13A~            	LD	A,CPU_RDR0
0049+  F13A~            	CALL	PRTHEXBYTE
0050+  F13A~            	PRTS(" BAUD=$")
0050+  F13A~            	PRTS(" BAUD=$")
0051+  F13A~            #IF ((BAUDRATE / 100) > 0)
0052+  F13A~            	LD	HL,BAUDRATE / 100
0053+  F13A~            	CALL	PRTDEC
0054+  F13A~            #ENDIF
0055+  F13A~            #IF ((BAUDRATE % 100) < 10)
0056+  F13A~            	PRTC("0")
0056+  F13A~            	PRTC("0")
0057+  F13A~            #ENDIF
0058+  F13A~            	LD	HL,BAUDRATE % 100
0059+  F13A~            	CALL	PRTDEC
0060+  F13A~            
0061+  F13A~            	LD	A,66H
0062+  F13A~            	OUT0	(CPU_ASEXT0),A
0063+  F13A~            	LD	A,64H
0064+  F13A~            	OUT0	(CPU_CNTLA0),A
0065+  F13A~            	LD	A,Z180_CNTLB0
0066+  F13A~            	OUT0	(CPU_CNTLB0),A
0067+  F13A~            
0068+  F13A~            	; ASCI1
0069+  F13A~            	CALL	NEWLINE
0070+  F13A~            	PRTS("ASCI1: IO=0x$")
0070+  F13A~            	PRTS("ASCI1: IO=0x$")
0071+  F13A~            	LD	A,CPU_TDR1
0072+  F13A~            	CALL	PRTHEXBYTE
0073+  F13A~            	CALL	PC_COMMA
0074+  F13A~            	LD	A,CPU_RDR1
0075+  F13A~            	CALL	PRTHEXBYTE
0076+  F13A~            	PRTS(" BAUD=$")
0076+  F13A~            	PRTS(" BAUD=$")
0077+  F13A~            #IF ((BAUDRATE / 100) > 0)
0078+  F13A~            	LD	HL,BAUDRATE / 100
0079+  F13A~            	CALL	PRTDEC
0080+  F13A~            #ENDIF
0081+  F13A~            #IF ((BAUDRATE % 100) < 10)
0082+  F13A~            	PRTC("0")
0082+  F13A~            	PRTC("0")
0083+  F13A~            #ENDIF
0084+  F13A~            	LD	HL,BAUDRATE % 100
0085+  F13A~            	CALL	PRTDEC
0086+  F13A~            
0087+  F13A~            	LD	A,66H
0088+  F13A~            	OUT0	(CPU_ASEXT1),A
0089+  F13A~            	LD	A,64H
0090+  F13A~            	OUT0	(CPU_CNTLA1),A
0091+  F13A~            	LD	A,Z180_CNTLB1
0092+  F13A~            	OUT0	(CPU_CNTLB1),A
0093+  F13A             #ELSE
0094+  F13A CD AC FB    	PRTS("UART0: IO=0x$")
0094+  F13D 55 41 52 54 
0094+  F141 30 3A 20 49 
0094+  F145 4F 3D 30 78 
0094+  F149 24 
0095+  F14A 3E 90       	LD	A,SIO_BASE
0096+  F14C CD C3 FB    	CALL	PRTHEXBYTE
0097+  F14F CD AC FB    	PRTS(" BAUD=$")
0097+  F152 20 42 41 55 
0097+  F156 44 3D 24 
0098+  F159             #IF ((BAUDRATE / 100) > 0)
0099+  F159 21 80 01    	LD	HL,BAUDRATE / 100
0100+  F15C CD 00 FD    	CALL	PRTDEC
0101+  F15F             #ENDIF
0102+  F15F             #IF ((BAUDRATE % 100) < 10)
0103+  F15F CD 98 FB    	PRTC("0")
0103+  F162 30          
0104+  F163             #ENDIF
0105+  F163 21 00 00    	LD	HL,BAUDRATE % 100
0106+  F166 CD 00 FD    	CALL	PRTDEC
0107+  F169             	
0108+  F169 CD 4B FB    	CALL	PC_SPACE
0109+  F16C             
0110+  F16C 3E 80       	LD	A,80H
0111+  F16E D3 93       	OUT	(SIO_LCR),A		; DLAB ON
0112+  F170 3E 03       	LD	A,UART0_DIV
0113+  F172 D3 90       	OUT	(SIO_DLL),A		; SET DIVISOR (LS)
0114+  F174 3E 00       	LD	A,00H
0115+  F176 D3 91       	OUT	(SIO_DLM),A		; SET DIVISOR (MS)
0116+  F178             
0117+  F178 06 03       	LD    	B,03H			; B = DEFAULT SETTING FOR MCR (DTR + RTS)
0118+  F17A             
0119+  F17A~            #IF (UARTAFC)
0120+  F17A~            	PRTS(" AFC$")
0120+  F17A~            	PRTS(" AFC$")
0121+  F17A~            	LD	A,$55			; TEST VALUE
0122+  F17A~            	OUT	(SIO_SCR),A		; SET SCRATCH REG TO TEST VALUE
0123+  F17A~            	LD	A,0BFH
0124+  F17A~            	OUT	(SIO_LCR),A		; SET LCR=$BF TO ATTEMPT TO ACCESS EFR
0125+  F17A~            	IN	A,(SIO_SCR)		; READ SCRATCH REGISTER
0126+  F17A~            	CP	$55			; IF $55, NO EFR
0127+  F17A~            	JR	NZ,UART_AFC1		; NZ, HAVE EFR, DO IT
0128+  F17A~            	SET	5,B			; ENABLE AUTO FLOW CONTROL
0129+  F17A~            	JR	UART_AFC2
0130+  F17A~            UART_AFC1:
0131+  F17A~            	LD	A,0C0H			; ENABLE CTS/RTS FLOW CONTROL
0132+  F17A~            	OUT	(SIO_EFR),A		; SAVE IT
0133+  F17A~            UART_AFC2:
0134+  F17A             #ENDIF
0135+  F17A             
0136+  F17A 3E 03       	LD	A,03H
0137+  F17C D3 93       	OUT	(SIO_LCR),A		; DLAB OFF, 8 DATA, 1 STOP, NO PARITY
0138+  F17E             
0139+  F17E 78          	LD	A,B			; LOAD MCR VALUE TO SET
0140+  F17F D3 94       	OUT  	(SIO_MCR),A		; SAVE IT
0141+  F181             
0142+  F181             #IF (UARTFIFO)
0143+  F181             ;	LD	A,07H			; ENABLE AND RESET FIFOS
0144+  F181 3E 01       	LD	A,01H			; ENABLE AND RESET FIFOS
0145+  F183 D3 92       	OUT	(SIO_FCR),A		; ENABLE FIFOS
0146+  F185 CD AC FB    	PRTS(" FIFO$")
0146+  F188 20 46 49 46 
0146+  F18C 4F 24 
0147+  F18E             #ENDIF
0148+  F18E             
0149+  F18E             #ENDIF
0150+  F18E C9          	RET
0151+  F18F             ;
0152+  F18F             ;
0153+  F18F             ;
0154+  F18F             UART0_IN:
0155+  F18F CD 99 F1    	CALL	UART0_IST
0156+  F192 B7          	OR	A
0157+  F193 28 FA       	JR	Z,UART0_IN
0158+  F195~            #IF (PLATFORM == PLT_N8)
0159+  F195~            	IN0	A,(CPU_RDR0)	; READ THE CHAR FROM THE UART
0160+  F195             #ELSE
0161+  F195 DB 90       	IN	A,(SIO_RBR)	; READ THE CHAR FROM THE UART
0162+  F197             #ENDIF
0163+  F197 5F          	LD	E,A
0164+  F198 C9          	RET
0165+  F199             ;
0166+  F199             ;
0167+  F199             ;
0168+  F199             UART0_IST:
0169+  F199~            #IF (PLATFORM == PLT_N8)
0170+  F199~            	; CHECK FOR ERROR FLAGS
0171+  F199~            	IN0	A,(CPU_STAT0)
0172+  F199~            	AND	70H			; PARITY, FRAMING, OR OVERRUN ERROR
0173+  F199~            	JR	Z,UART0_IST1		; ALL IS WELL, CHECK FOR DATA
0174+  F199~            
0175+  F199~            	; CLEAR ERROR(S) OR NOTHING FURTHER CAN BE RECEIVED!!!
0176+  F199~            	IN0	A,(CPU_CNTLA0)
0177+  F199~            	RES	3,A			; CLEAR EFR (ERROR FLAG RESET)
0178+  F199~            	OUT0	(CPU_CNTLA0),A
0179+  F199~            
0180+  F199~            UART0_IST1:	; CHECK FOR STAT0.RDRF (DATA READY)
0181+  F199~            	IN0	A,(CPU_STAT0)		; READ LINE STATUS REGISTER
0182+  F199~            	AND	$80			; TEST IF DATA IN RECEIVE BUFFER
0183+  F199             #ELSE
0184+  F199 DB 95       	IN	A,(SIO_LSR)		; READ LINE STATUS REGISTER
0185+  F19B E6 01       	AND	$01			; TEST IF DATA IN RECEIVE BUFFER
0186+  F19D             #ENDIF
0187+  F19D CA 1C F1    	JP	Z,CIO_IDLE		; DO IDLE PROCESSING AND RETURN
0188+  F1A0 AF          	XOR	A
0189+  F1A1 3C          	INC	A			; SIGNAL CHAR READY, A = 1
0190+  F1A2 C9          	RET
0191+  F1A3             ;
0192+  F1A3             ;
0193+  F1A3             ;
0194+  F1A3             UART0_OUT:
0195+  F1A3 CD AD F1    	CALL	UART0_OST
0196+  F1A6 B7          	OR	A
0197+  F1A7 28 FA       	JR	Z,UART0_OUT
0198+  F1A9 7B          	LD	A,E
0199+  F1AA~            #IF (PLATFORM == PLT_N8)
0200+  F1AA~            	OUT0	(CPU_TDR0),A
0201+  F1AA             #ELSE
0202+  F1AA D3 90       	OUT	(SIO_THR),A		; THEN WRITE THE CHAR TO UART
0203+  F1AC             #ENDIF
0204+  F1AC C9          	RET
0205+  F1AD             ;
0206+  F1AD             UART0_OST:
0207+  F1AD~            #IF (PLATFORM == PLT_N8)
0208+  F1AD~            	IN0	A,(CPU_STAT0)
0209+  F1AD~            	AND	$02
0210+  F1AD             #ELSE
0211+  F1AD DB 95       	IN	A,(SIO_LSR)		; READ LINE STATUS REGISTER
0212+  F1AF E6 20       	AND	$20
0213+  F1B1             #ENDIF
0214+  F1B1 CA 1C F1    	JP	Z,CIO_IDLE		; DO IDLE PROCESSING AND RETURN
0215+  F1B4 AF          	XOR	A
0216+  F1B5 3C          	INC	A			; SIGNAL BUFFER EMPTY, A = 1
0217+  F1B6 C9          	RET
0218+  F1B7             ;
0219+  F1B7             ;
0220+  F1B7             ;
0221+  F1B7~            #IF (PLATFORM == PLT_N8)
0222+  F1B7~            ;
0223+  F1B7~            UART1:
0224+  F1B7~            	LD	A,B	; GET REQUESTED FUNCTION
0225+  F1B7~            	AND	$0F	; ISOLATE SUB-FUNCTION
0226+  F1B7~            	JR	Z,UART0_IN
0227+  F1B7~            	DEC	A
0228+  F1B7~            	JR	Z,UART0_OUT
0229+  F1B7~            	DEC	A
0230+  F1B7~            	JR	Z,UART0_IST
0231+  F1B7~            	DEC	A
0232+  F1B7~            	JR	Z,UART0_OST
0233+  F1B7~            	CALL	PANIC
0234+  F1B7~            ;
0235+  F1B7~            ;
0236+  F1B7~            ;
0237+  F1B7~            UART1_IN:
0238+  F1B7~            	CALL	UART1_IST
0239+  F1B7~            	OR	A
0240+  F1B7~            	JR	Z,UART1_IN
0241+  F1B7~            	IN0	A,(CPU_RDR1)	; READ THE CHAR FROM THE UART
0242+  F1B7~            	LD	E,A
0243+  F1B7~            	RET
0244+  F1B7~            ;
0245+  F1B7~            ;
0246+  F1B7~            ;
0247+  F1B7~            UART1_IST:
0248+  F1B7~            	; CHECK FOR ERROR FLAGS
0249+  F1B7~            	IN0	A,(CPU_STAT1)
0250+  F1B7~            	AND	70H			; PARITY, FRAMING, OR OVERRUN ERROR
0251+  F1B7~            	JR	Z,UART1_IST1		; ALL IS WELL, CHECK FOR DATA
0252+  F1B7~            
0253+  F1B7~            	; CLEAR ERROR(S) OR NOTHING FURTHER CAN BE RECEIVED!!!
0254+  F1B7~            	IN0	A,(CPU_CNTLA1)
0255+  F1B7~            	RES	3,A			; CLEAR EFR (ERROR FLAG RESET)
0256+  F1B7~            	OUT0	(CPU_CNTLA1),A
0257+  F1B7~            
0258+  F1B7~            UART1_IST1:	; CHECK FOR STAT0.RDRF (DATA READY)
0259+  F1B7~            	IN0	A,(CPU_STAT1)		; READ LINE STATUS REGISTER
0260+  F1B7~            	AND	$80			; TEST IF DATA IN RECEIVE BUFFER
0261+  F1B7~            	JP	Z,CIO_IDLE		; DO IDLE PROCESSING AND RETURN
0262+  F1B7~            	XOR	A
0263+  F1B7~            	INC	A			; SIGNAL CHAR READY, A = 1
0264+  F1B7~            	RET
0265+  F1B7~            ;
0266+  F1B7~            ;
0267+  F1B7~            ;
0268+  F1B7~            UART1_OUT:
0269+  F1B7~            	CALL	UART1_OST
0270+  F1B7~            	OR	A
0271+  F1B7~            	JR	Z,UART1_OUT
0272+  F1B7~            	LD	A,E
0273+  F1B7~            	OUT0	(CPU_TDR1),A
0274+  F1B7~            	RET
0275+  F1B7~            ;
0276+  F1B7~            UART1_OST:
0277+  F1B7~            	IN0	A,(CPU_STAT1)
0278+  F1B7~            	AND	$02
0279+  F1B7~            	JR	Z,UART1_OST
0280+  F1B7~            	JP	Z,CIO_IDLE		; DO IDLE PROCESSING AND RETURN
0281+  F1B7~            	XOR	A
0282+  F1B7~            	INC	A			; SIGNAL BUFFER EMPTY, A = 1
0283+  F1B7~            	RET
0284+  F1B7             #ENDIF
0332   F1B7             SIZ_UART	.EQU	$ - ORG_UART
0333   F1B7             		.ECHO	"UART occupies "
0334   F1B7             		.ECHO	SIZ_UART
0335   F1B7             		.ECHO	" bytes.\n"
0336   F1B7             #ENDIF
0337   F1B7             ;
0338   F1B7             #IF (PPIDEENABLE)
0339   F1B7             ORG_PPIDE	.EQU	$
0340   F1B7               #INCLUDE "ppide.asm"
0001+  F1B7             ;
0002+  F1B7             ;==================================================================================================
0003+  F1B7             ;   PPIDE DISK DRIVER
0004+  F1B7             ;==================================================================================================
0005+  F1B7             ;
0006+  F1B7             ; 11/29/2011 dwg - DOUGDEBUG controls the embedded NOPs which adjust for
0007+  F1B7             ; recovery time while using the parallel port to talk to the PPIDE and IDE
0008+  F1B7             ; device. Using this stabilized by Zeta (8MHz) with a CF chip.
0009+  F1B7             ;
0010+  F1B7             ; 12/02/2011 wbw - renamed DOUGDEBUG to PPIDESLOW and exposed in config
0011+  F1B7             ; PPIDESLOW now controls the RECOVERY macro definition.
0012+  F1B7             ;
0013+  F1B7~            #IF (PPIDESLOW)
0014+  F1B7~            #DEFINE RECOVERY	NOP\	NOP\	NOP\	NOP
0015+  F1B7             #ELSE
0016+  F1B7             #DEFINE RECOVERY 	;
0017+  F1B7             #ENDIF
0018+  F1B7             ;
0019+  F1B7             ; MAP PPI PORTS TO PPIDE PORTS
0020+  F1B7             ;
0021+  F1B7             IDELSB		.EQU	PPIDEIOB + 0	; LSB
0022+  F1B7             IDEMSB		.EQU	PPIDEIOB + 1	; MSB
0023+  F1B7             IDECTL		.EQU	PPIDEIOB + 2	; CONTROL SIGNALS
0024+  F1B7             PPICTL		.EQU	PPIDEIOB + 3	; PPI (8255) CONTROL PORT
0025+  F1B7             ;
0026+  F1B7             ; PPI control bytes for read and write to IDE drive
0027+  F1B7             ;
0028+  F1B7             RD_IDE_8255	.EQU	%10010010	; IDE_8255_CTL OUT, IDE_8255_LSB/MSB INPUT
0029+  F1B7             WR_IDE_8255	.EQU	%10000000	; ALL THREE PORTS OUTPUT
0030+  F1B7             ;
0031+  F1B7             ; IDE CONTROL LINES FOR USE WITH IDE_8255_CTL.  CHANGE THESE 8
0032+  F1B7             ; CONSTANTS TO REFLECT WHERE EACH SIGNAL OF THE 8255 EACH OF THE
0033+  F1B7             ; IDE CONTROL SIGNALS IS CONNECTED.  ALL THE CONTROL SIGNALS MUST
0034+  F1B7             ; BE ON THE SAME PORT, BUT THESE 8 LINES LET YOU CONNECT THEM TO
0035+  F1B7             ; WHICHEVER PINS ON THAT PORT.
0036+  F1B7             ;
0037+  F1B7             PPIDE_A0_LINE	.EQU	$01	; DIRECT FROM 8255 TO IDE INTERFACE
0038+  F1B7             PPIDE_A1_LINE	.EQU	$02	; DIRECT FROM 8255 TO IDE INTERFACE
0039+  F1B7             PPIDE_A2_LINE	.EQU	$04	; DIRECT FROM 8255 TO IDE INTERFACE
0040+  F1B7             PPIDE_CS0_LINE	.EQU	$08	; INVERTER BETWEEN 8255 AND IDE INTERFACE
0041+  F1B7             PPIDE_CS1_LINE	.EQU	$10	; INVERTER BETWEEN 8255 AND IDE INTERFACE
0042+  F1B7             PPIDE_WR_LINE	.EQU	$20	; INVERTER BETWEEN 8255 AND IDE INTERFACE
0043+  F1B7             PPIDE_RD_LINE	.EQU	$40	; INVERTER BETWEEN 8255 AND IDE INTERFACE
0044+  F1B7             PPIDE_RST_LINE	.EQU	$80	; INVERTER BETWEEN 8255 AND IDE INTERFACE
0045+  F1B7             ;
0046+  F1B7             ;------------------------------------------------------------------
0047+  F1B7             ; MORE SYMBOLIC CONSTANTS... THESE SHOULD NOT BE CHANGED, UNLESS OF
0048+  F1B7             ; COURSE THE IDE DRIVE INTERFACE CHANGES, PERHAPS WHEN DRIVES GET
0049+  F1B7             ; TO 128G AND THE PC INDUSTRY WILL DO YET ANOTHER KLUDGE.
0050+  F1B7             ;
0051+  F1B7             ; SOME SYMBOLIC CONSTANTS FOR THE IDE REGISTERS, WHICH MAKES THE
0052+  F1B7             ; CODE MORE READABLE THAN ALWAYS SPECIFYING THE ADDRESS PINS
0053+  F1B7             ;
0054+  F1B7             PPIDE_DATA	.EQU    PPIDE_CS0_LINE
0055+  F1B7             PPIDE_ERROR	.EQU    PPIDE_CS0_LINE + PPIDE_A0_LINE
0056+  F1B7             PPIDE_FEATURE	.EQU    PPIDE_CS0_LINE + PPIDE_A0_LINE
0057+  F1B7             PPIDE_SEC_CNT	.EQU    PPIDE_CS0_LINE + PPIDE_A1_LINE
0058+  F1B7             PPIDE_SECTOR	.EQU    PPIDE_CS0_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0059+  F1B7             PPIDE_CYL_LSB	.EQU    PPIDE_CS0_LINE + PPIDE_A2_LINE
0060+  F1B7             PPIDE_CYL_MSB	.EQU    PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A0_LINE
0061+  F1B7             PPIDE_HEAD	.EQU    PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0062+  F1B7             PPIDE_COMMAND	.EQU    PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0063+  F1B7             PPIDE_STTS	.EQU    PPIDE_CS0_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0064+  F1B7             PPIDE_CONTROL	.EQU    PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE
0065+  F1B7             PPIDE_ASTTS	.EQU    PPIDE_CS1_LINE + PPIDE_A2_LINE + PPIDE_A1_LINE + PPIDE_A0_LINE
0066+  F1B7             ;
0067+  F1B7             ; IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
0068+  F1B7             ;
0069+  F1B7             PPIDE_CMDRECAL		.EQU	$10
0070+  F1B7             PPIDE_CMDREAD		.EQU	$20
0071+  F1B7             PPIDE_CMDWRITE		.EQU	$30
0072+  F1B7             PPIDE_CMDINIT		.EQU	$91
0073+  F1B7             PPIDE_CMDID		.EQU	$EC
0074+  F1B7             PPIDE_CMDSPINDOWN	.EQU	$E0
0075+  F1B7             PPIDE_CMDSPINUP		.EQU	$E1
0076+  F1B7             PPIDE_CMDSETFEAT	.EQU	$EF
0077+  F1B7             ;
0078+  F1B7             PPIDE_RCOK		.EQU	0
0079+  F1B7             PPIDE_RCCMDERR		.EQU	1
0080+  F1B7             PPIDE_RCRDYTO		.EQU	2
0081+  F1B7             PPIDE_RCBUFTO		.EQU	3
0082+  F1B7             ;
0083+  F1B7             ; UNIT CONFIGURATION
0084+  F1B7             ;
0085+  F1B7 E0          PPIDE_UNIT0		.DB	%11100000	; LBA, MASTER DEVICE
0086+  F1B8 F0          PPIDE_UNIT1		.DB	%11110000	; LBA, SLAVE DEVICE
0087+  F1B9             ;
0088+  F1B9             ;
0089+  F1B9             ;
0090+  F1B9             PPIDE_DISPATCH:
0091+  F1B9 78          	LD	A,B		; GET REQUESTED FUNCTION
0092+  F1BA E6 0F       	AND	$0F
0093+  F1BC 28 0C       	JR	Z,PPIDE_RD
0094+  F1BE 3D          	DEC	A
0095+  F1BF 28 11       	JR	Z,PPIDE_WR
0096+  F1C1 3D          	DEC	A
0097+  F1C2 28 16       	JR	Z,PPIDE_ST
0098+  F1C4 3D          	DEC	A
0099+  F1C5 28 18       	JR	Z,PPIDE_MED
0100+  F1C7 CD 23 FC    	CALL	PANIC
0101+  F1CA             ;
0102+  F1CA             PPIDE_RD:
0103+  F1CA 3E 20       	LD	A,PPIDE_CMDREAD
0104+  F1CC 32 EE F4    	LD	(PPIDEP_CMD),A
0105+  F1CF C3 0C F2    	JP	PPIDE_RW
0106+  F1D2             ;
0107+  F1D2             PPIDE_WR:
0108+  F1D2 3E 30       	LD	A,PPIDE_CMDWRITE
0109+  F1D4 32 EE F4    	LD	(PPIDEP_CMD),A
0110+  F1D7 C3 0C F2    	JP	PPIDE_RW
0111+  F1DA             ;
0112+  F1DA             PPIDE_ST:
0113+  F1DA 3A EC F4    	LD	A,(PPIDE_STAT)	; LOAD STATUS
0114+  F1DD B7          	OR	A		; SET FLAGS
0115+  F1DE C9          	RET
0116+  F1DF             ;
0117+  F1DF             PPIDE_MED:
0118+  F1DF 3E 03       	LD	A,MID_HD
0119+  F1E1 C9          	RET
0120+  F1E2             ;
0121+  F1E2             ;
0122+  F1E2             ;
0123+  F1E2             PPIDE_INIT:
0124+  F1E2 CD AC FB    	PRTS("PPIDE: IO=0x$")
0124+  F1E5 50 50 49 44 
0124+  F1E9 45 3A 20 49 
0124+  F1ED 4F 3D 30 78 
0124+  F1F1 24 
0125+  F1F2 3E 80       	LD	A,IDELSB
0126+  F1F4 CD C3 FB    	CALL	PRTHEXBYTE
0127+  F1F7 CD AC FB    	PRTS(" UNITS=2$")
0127+  F1FA 20 55 4E 49 
0127+  F1FE 54 53 3D 32 
0127+  F202 24 
0128+  F203~            #IF (PPIDE8BIT)
0129+  F203~            	PRTS(" 8BIT$")
0129+  F203~            	PRTS(" 8BIT$")
0130+  F203             #ENDIF
0131+  F203~            #IF (PPIDESLOW)
0132+  F203~            	PRTS(" SLOW$")
0132+  F203~            	PRTS(" SLOW$")
0133+  F203             #ENDIF
0134+  F203 CD 7B F2    	CALL	PPIDE_RESET
0135+  F206 AF          	XOR	A
0136+  F207 3D          	DEC	A		; INITIAL STATUS IS NOT READY $FF
0137+  F208 32 EC F4    	LD	(PPIDE_STAT),A	; SAVE IT
0138+  F20B C9          	RET
0139+  F20C             ;
0140+  F20C             ;
0141+  F20C             ;
0142+  F20C             PPIDE_RW:
0143+  F20C             	; INIT REQUIRED?
0144+  F20C 3A EC F4    	LD	A,(PPIDE_STAT)
0145+  F20F B7          	OR	A			; SET FLAGS
0146+  F210 28 03       	JR	Z,PPIDE_RW0		; IF STATUS OK, BYPASS RESET
0147+  F212             
0148+  F212 CD 7B F2    	CALL	PPIDE_RESET		; DO THE RESET
0149+  F215             	; NEED TO CHECK STATUS HERE!!!
0150+  F215             
0151+  F215             PPIDE_RW0:
0152+  F215             	; CLEAR RESULTS
0153+  F215 AF          	XOR	A			; A = 0
0154+  F216 32 ED F4    	LD	(PPIDE_RC),A		; CLEAR RETURN CODE
0155+  F219 32 F3 F4    	LD	(PPIDEP_STTS),A		; CLEAR SAVED STTS
0156+  F21C 32 F4 F4    	LD	(PPIDEP_ERR),A		; CLEAR SAVED ERR
0157+  F21F             
0158+  F21F CD 94 F2    	CALL	PPIDE_WAITRDY		; WAIT FOR DRIVE READY
0159+  F222 D2 6E F2    	JP	NC,PPIDE_ERR
0160+  F225 CD 58 F3    	CALL	PPIDE_SETUP		; SETUP CYL, TRK, HEAD
0161+  F228 0E 0F       	LD	C,PPIDE_COMMAND		; IDE COMMAND REGISTER
0162+  F22A 3A EE F4    	LD	A,(PPIDEP_CMD)		; COMMAND VALUE
0163+  F22D CD BD F3    	CALL	PPIDE_WRITE		; DO IT
0164+  F230 CD 94 F2    	CALL	PPIDE_WAITRDY		; WAIT FOR DRIVE READY
0165+  F233 D2 6E F2    	JP	NC,PPIDE_ERR
0166+  F236 CD BD F2    	CALL	PPIDE_CHKERR		; CHECK FOR ERRORS
0167+  F239 D2 6E F2    	JP	NC,PPIDE_ERR
0168+  F23C CD D8 F2    	CALL	PPIDE_WAITBUF		; WAIT FOR BUFFER READY
0169+  F23F D2 6E F2    	JP	NC,PPIDE_ERR
0170+  F242             
0171+  F242 3A EE F4    	LD	A,(PPIDEP_CMD)		; DISPATCH TO READ OR WRITE SPECIFIC LOGIC
0172+  F245 FE 30       	CP	PPIDE_CMDWRITE
0173+  F247 CA 5C F2    	JP	Z,PPIDE_RW1
0174+  F24A             
0175+  F24A CD FC F2    	CALL	PPIDE_BUFRD		; READ BUFFER
0176+  F24D CD 94 F2    	CALL	PPIDE_WAITRDY	 	; WAIT FOR DRIVE READY
0177+  F250 D2 6E F2    	JP	NC,PPIDE_ERR
0178+  F253 CD BD F2    	CALL	PPIDE_CHKERR		; CHECK FOR ERRORS
0179+  F256 D2 6E F2    	JP	NC,PPIDE_ERR
0180+  F259 C3 79 F2    	JP	PPIDE_OK
0181+  F25C             
0182+  F25C             PPIDE_RW1:
0183+  F25C CD 2A F3    	CALL	PPIDE_BUFWR 		; WRITE BUFFER
0184+  F25F CD 94 F2    	CALL	PPIDE_WAITRDY	 	; WAIT FOR DRIVE READY
0185+  F262 D2 6E F2    	JP	NC,PPIDE_ERR
0186+  F265 CD BD F2    	CALL	PPIDE_CHKERR		; CHECK FOR ERRORS
0187+  F268 D2 6E F2    	JP	NC,PPIDE_ERR
0188+  F26B C3 79 F2    	JP	PPIDE_OK
0189+  F26E             
0190+  F26E             PPIDE_ERR:
0191+  F26E AF          	XOR	A
0192+  F26F 3D          	DEC	A			; A = $FF TO SIGNAL ERROR
0193+  F270 32 EC F4    	LD	(PPIDE_STAT),A		; SAVE IT
0194+  F273             #IF (PPIDETRACE >= 1)
0195+  F273 F5          	PUSH 	AF
0196+  F274 CD D4 F3    	CALL	PPIDE_PRT
0197+  F277 F1          	POP	AF
0198+  F278             #ENDIF
0199+  F278 C9          	RET
0200+  F279             
0201+  F279             PPIDE_OK:
0202+  F279~            #IF (PPIDETRACE >= 2)
0203+  F279~            	CALL	PPIDE_PRT
0204+  F279             #ENDIF
0205+  F279 AF          	XOR	A
0206+  F27A C9          	RET
0207+  F27B             ;
0208+  F27B             ;
0209+  F27B             ;
0210+  F27B             PPIDE_RESET:
0211+  F27B~            #IF (PPIDETRACE >= 2)
0212+  F27B~            	CALL	NEWLINE
0213+  F27B~            	PRTX(PPIDESTR_PREFIX)
0213+  F27B~            	PRTX(PPIDESTR_PREFIX)
0214+  F27B~            	PRTS(" RESET$")
0214+  F27B~            	PRTS(" RESET$")
0215+  F27B             #ENDIF
0216+  F27B~            #IF (PPIDETRACE >= 2)
0217+  F27B~            	CALL	PC_PERIOD
0218+  F27B             #ENDIF
0219+  F27B 0E 16       	LD	C,PPIDE_CONTROL		; IDE CONTROL REGISTER
0220+  F27D 3E 0E       	LD	A,000001110B		; NO INTERRUPTS, ASSERT RESET BOTH DRIVES
0221+  F27F CD BD F3    	CALL	PPIDE_WRITE		; DO IT
0222+  F282 11 08 00    	LD	DE,8			; DELAY ABOUT 200ms
0223+  F285 CD E1 FC    	CALL	VDELAY
0224+  F288~            #IF (PPIDETRACE >= 2)
0225+  F288~            	CALL	PC_PERIOD
0226+  F288             #ENDIF
0227+  F288 0E 16       	LD	C,PPIDE_CONTROL		; IDE CONTROL REGISTER
0228+  F28A 3E 02       	LD	A,000000010B		; NO INTERRUPTS, DEASSERT RESET
0229+  F28C CD BD F3    	CALL	PPIDE_WRITE		; DO IT
0230+  F28F AF          	XOR	A			; STATUS OK
0231+  F290 32 EC F4    	LD	(PPIDE_STAT),A		; SAVE IT
0232+  F293             
0233+  F293~            #IF (PPIDE8BIT)
0234+  F293~            
0235+  F293~            #IF (PPIDETRACE >= 2)
0236+  F293~            	CALL	PC_PERIOD
0237+  F293~            #ENDIF
0238+  F293~            	CALL	PPIDE_WAITRDY
0239+  F293~            
0240+  F293~            #IF (PPIDETRACE >= 2)
0241+  F293~            	CALL	PC_PERIOD
0242+  F293~            #ENDIF
0243+  F293~            	LD	C,PPIDE_FEATURE		; IDE FEATURE REGISTER
0244+  F293~            	LD	A,01H			; VALUE := 1
0245+  F293~            	CALL	PPIDE_WRITE		; DO IT
0246+  F293~            
0247+  F293~            #IF (PPIDETRACE >= 2)
0248+  F293~            	CALL	PC_PERIOD
0249+  F293~            #ENDIF
0250+  F293~            	LD	C,PPIDE_COMMAND		; IDE COMMAND REGISTER
0251+  F293~            	LD	A,PPIDE_CMDSETFEAT	; SET FEATURE
0252+  F293~            	CALL	PPIDE_WRITE		; DO IT
0253+  F293~            
0254+  F293~            #IF (PPIDETRACE >= 2)
0255+  F293~            	CALL	PC_PERIOD
0256+  F293~            #ENDIF
0257+  F293~            
0258+  F293             #ENDIF
0259+  F293             
0260+  F293 C9          	RET
0261+  F294             ;
0262+  F294             ;
0263+  F294             ;
0264+  F294             PPIDE_WAITRDY:
0265+  F294 11 00 00    	LD	DE,0			; TIMEOUT IS 250us * 65536 = 15 SECONDS
0266+  F297             PPIDE_WBSY:
0267+  F297 D5          	PUSH	DE
0268+  F298 11 0A 00    	LD	DE,10			; INNER LOOP DELAY IS 250us (25us * 10)
0269+  F29B CD E1 FC    	CALL	VDELAY
0270+  F29E D1          	POP	DE
0271+  F29F 1B          	DEC	DE
0272+  F2A0 7A          	LD	A,D
0273+  F2A1 B3          	OR	E
0274+  F2A2 CA B6 F2    	JP	Z,PPIDE_TO
0275+  F2A5 0E 0F       	LD	C,PPIDE_STTS		; IDE STATUS REGISTER
0276+  F2A7 CD A7 F3    	CALL	PPIDE_READ		; READ ID
0277+  F2AA 32 F3 F4    	LD	(PPIDEP_STTS),A		; SAVE IT
0278+  F2AD E6 C0       	AND	011000000B		; ISOLATE BUSY AND RDY BITS
0279+  F2AF EE 40       	XOR	001000000B		; WE WANT BUSY(7) TO BE 0 AND RDY(6) TO BE 1
0280+  F2B1 C2 97 F2    	JP	NZ,PPIDE_WBSY
0281+  F2B4 37          	SCF				; CARRY 1 = OK
0282+  F2B5 C9          	RET
0283+  F2B6             PPIDE_TO:
0284+  F2B6 3E 02       	LD	A,PPIDE_RCRDYTO
0285+  F2B8 32 ED F4    	LD	(PPIDE_RC),A
0286+  F2BB AF          	XOR	A			; CARRY 0 = TIMEOUT
0287+  F2BC C9          	RET
0288+  F2BD             ;
0289+  F2BD             ;
0290+  F2BD             ;
0291+  F2BD             PPIDE_CHKERR:
0292+  F2BD 0E 0F       	LD	C,PPIDE_STTS		; IDE STATUS REGISTER
0293+  F2BF CD A7 F3    	CALL	PPIDE_READ		; READ IT
0294+  F2C2 32 F3 F4    	LD	(PPIDEP_STTS),A		; SAVE IT
0295+  F2C5 E6 01       	AND	000000001B		; ERROR BIT SET?
0296+  F2C7 37          	SCF				; ASSUME NO ERR
0297+  F2C8 C8          	RET	Z			; NO ERR, RETURN WITH CF SET
0298+  F2C9             ;
0299+  F2C9 0E 09       	LD	C,PPIDE_ERROR		; IDE ERROR REGISTER
0300+  F2CB CD A7 F3    	CALL	PPIDE_READ		; READ IT
0301+  F2CE 32 F4 F4    	LD	(PPIDEP_ERR),A		; SAVE IT
0302+  F2D1             ;
0303+  F2D1 3E 01       	LD	A,PPIDE_RCCMDERR	; COMMAND ERROR
0304+  F2D3 32 ED F4    	LD	(PPIDE_RC),A		; SAVE IT
0305+  F2D6             ;
0306+  F2D6 B7          	OR	A			; CLEAR CF TO SIGNAL ERROR
0307+  F2D7 C9          	RET
0308+  F2D8             ;
0309+  F2D8             ;
0310+  F2D8             ;
0311+  F2D8             PPIDE_WAITBUF:
0312+  F2D8 11 00 00    	LD	DE,0
0313+  F2DB             PPIDE_WDRQ:
0314+  F2DB CD DA FC    	CALL	DELAY
0315+  F2DE 13          	INC	DE
0316+  F2DF 7A          	LD	A,D
0317+  F2E0 B3          	OR	E
0318+  F2E1 CA F5 F2    	JP	Z,PPIDE_TO2
0319+  F2E4 0E 0F       	LD	C,PPIDE_STTS		; IDE STATUS REGISTER
0320+  F2E6 CD A7 F3    	CALL	PPIDE_READ		; READ IT
0321+  F2E9 32 F3 F4    	LD	(PPIDEP_STTS),A		; SAVE IT
0322+  F2EC E6 88       	AND	010001000B		; TO FILL (OR READY TO FILL)
0323+  F2EE EE 08       	XOR	000001000B
0324+  F2F0 C2 DB F2    	JP	NZ,PPIDE_WDRQ
0325+  F2F3 37          	SCF				; CARRY 1 = OK
0326+  F2F4 C9          	RET
0327+  F2F5             PPIDE_TO2:
0328+  F2F5 3E 03       	LD	A,PPIDE_RCBUFTO
0329+  F2F7 32 ED F4    	LD	(PPIDE_RC),A
0330+  F2FA AF          	XOR	A			; CARRY 0 = TIMED OUT
0331+  F2FB C9          	RET
0332+  F2FC             ;
0333+  F2FC             ;
0334+  F2FC             ;
0335+  F2FC             PPIDE_BUFRD:
0336+  F2FC             	; SETUP PPI TO READ
0337+  F2FC 3E 92       	LD	A,RD_IDE_8255		; READ CONFIG
0338+  F2FE D3 83       	OUT	(PPICTL),A		; DO IT
0339+  F300             	RECOVERY			; OPTIONAL SMALL DELAY
0340+  F300             ;
0341+  F300             	; SELECT READ/WRITE IDE REGISTER
0342+  F300 3E 08       	LD	A,PPIDE_DATA		; DATA REGISTER
0343+  F302 D3 82       	OUT	(IDECTL),A		; DO IT
0344+  F304             	RECOVERY			; OPTIONAL SMALL DELAY
0345+  F304 5F          	LD	E,A			; E := READ UNASSERTED
0346+  F305 EE 40       	XOR	PPIDE_RD_LINE		; SWAP THE READ LINE BIT
0347+  F307 57          	LD	D,A			; D := READ ASSERTED
0348+  F308             ;
0349+  F308             	; LOOP SETUP
0350+  F308 2A 49 FD    	LD	HL,(DIOBUF)		; LOCATION OF BUFFER
0351+  F30B 06 00       	LD	B,0			; 256 ITERATIONS
0352+  F30D 0E 80       	LD	C,IDELSB		; SETUP C WITH IO PORT (LSB)
0353+  F30F             ;
0354+  F30F CD 19 F3    	CALL	PPIDE_BUFRD1		; FIRST PASS (FIRST 256 BYTES)
0355+  F312 CD 19 F3    	CALL	PPIDE_BUFRD1		; SECOND PASS (LAST 256 BYTES)
0356+  F315             ;
0357+  F315             	; CLEAN UP
0358+  F315 AF          	XOR	A			; ZERO A
0359+  F316 D3 82       	OUT	(IDECTL),A		; RELEASE ALL BUS SIGNALS
0360+  F318             	RECOVERY			; OPTIONAL SMALL DELAY
0361+  F318 C9          	RET
0362+  F319             ;
0363+  F319             PPIDE_BUFRD1:	; START OF READ LOOP
0364+  F319 7A          	LD	A,D			; ASSERT READ
0365+  F31A D3 82       	OUT	(IDECTL),A		; DO IT
0366+  F31C             	RECOVERY			; OPTIONAL SMALL DELAY
0367+  F31C ED A2       	INI				; GET AND SAVE NEXT BYTE
0368+  F31E             	RECOVERY			; OPTIONAL SMALL DELAY
0369+  F31E             #IF (!PPIDE8BIT)
0370+  F31E 0C          	INC	C			; LSB -> MSB
0371+  F31F ED A2       	INI				; GET AND SAVE NEXT BYTE
0372+  F321             	RECOVERY			; OPTIONAL SMALL DELAY
0373+  F321 F5          	PUSH	AF
0374+  F322 0D          	DEC	C			; MSB -> LSB
0375+  F323 F1          	POP	AF
0376+  F324             #ENDIF
0377+  F324 7B          	LD	A,E			; DEASSERT READ
0378+  F325 D3 82       	OUT	(IDECTL),A		; DO IT
0379+  F327             	RECOVERY			; OPTIONAL SMALL DELAY
0380+  F327             ;
0381+  F327 20 F0       	JR	NZ,PPIDE_BUFRD1		; LOOP UNTIL DONE
0382+  F329 C9          	RET
0383+  F32A             ;
0384+  F32A             ;
0385+  F32A             ;
0386+  F32A             PPIDE_BUFWR:
0387+  F32A             	; SETUP PPI TO WRITE
0388+  F32A 3E 80       	LD	A,WR_IDE_8255		; WRITE CONFIG
0389+  F32C D3 83       	OUT	(PPICTL),A		; DO IT
0390+  F32E             	RECOVERY			; OPTIONAL SMALL DELAY
0391+  F32E             ;
0392+  F32E             	; SELECT READ/WRITE IDE REGISTER
0393+  F32E 3E 08       	LD	A,PPIDE_DATA		; DATA REGISTER
0394+  F330 D3 82       	OUT	(IDECTL),A		; DO IT
0395+  F332             	RECOVERY			; OPTIONAL SMALL DELAY
0396+  F332 5F          	LD	E,A			; E := WRITE UNASSERTED
0397+  F333 EE 20       	XOR	PPIDE_WR_LINE		; SWAP THE WRITE LINE BIT
0398+  F335 57          	LD	D,A			; D := WRITE ASSERTED
0399+  F336             ;
0400+  F336             	; LOOP SETUP
0401+  F336 2A 49 FD    	LD	HL,(DIOBUF)		; LOCATION OF BUFFER
0402+  F339 06 00       	LD	B,0			; 256 ITERATIONS
0403+  F33B 0E 80       	LD	C,IDELSB		; SETUP C WITH IO PORT (LSB)
0404+  F33D             ;
0405+  F33D CD 47 F3    	CALL	PPIDE_BUFWR1		; FIRST PASS (FIRST 256 BYTES)
0406+  F340 CD 47 F3    	CALL	PPIDE_BUFWR1		; SECOND PASS (LAST 256 BYTES)
0407+  F343             ;
0408+  F343             	; CLEAN UP
0409+  F343 AF          	XOR	A			; ZERO A
0410+  F344 D3 82       	OUT	(IDECTL),A		; RELEASE ALL BUS SIGNALS
0411+  F346             	RECOVERY			; OPTIONAL SMALL DELAY
0412+  F346 C9          	RET
0413+  F347             ;
0414+  F347             PPIDE_BUFWR1:	; START OF WRITE LOOP
0415+  F347 ED A3       	OUTI				; SEND NEXT BYTE OF BUFFER
0416+  F349             	RECOVERY			; OPTIONAL SMALL DELAY
0417+  F349             #IF (!PPIDE8BIT)
0418+  F349 0C          	INC	C			; LSB -> MSB
0419+  F34A ED A3       	OUTI				; SEND NEXT BYTE OF BUFFER
0420+  F34C F5          	PUSH	AF
0421+  F34D 0D          	DEC	C			; MSB -> LSB
0422+  F34E F1          	POP	AF
0423+  F34F             	RECOVERY			; OPTIONAL SMALL DELAY
0424+  F34F             #ENDIF
0425+  F34F             ;
0426+  F34F             	; TOGGLE THE WRITE LINE
0427+  F34F 7A          	LD	A,D			; WRITE ASSERTED VALUE
0428+  F350 D3 82       	OUT	(IDECTL),A		; DO IT
0429+  F352             	RECOVERY			; OPTIONAL SMALL DELAY
0430+  F352 7B          	LD	A,E			; WRITE UNASSERTED VALUE
0431+  F353 D3 82       	OUT	(IDECTL),A		; DO IT
0432+  F355             	RECOVERY			; OPTIONAL SMALL DELAY
0433+  F355             ;
0434+  F355 20 F0       	JR	NZ,PPIDE_BUFWR1		; LOOP UNTIL DONE
0435+  F357 C9          	RET
0436+  F358             ;
0437+  F358             ;
0438+  F358             ;
0439+  F358             PPIDE_SETUP:
0440+  F358 0E 0A       	LD	C,PPIDE_SEC_CNT		; IDE SECTOR COUNT REGISTER
0441+  F35A 3E 01       	LD	A,1			; 1 SECTOR
0442+  F35C CD BD F3    	CALL	PPIDE_WRITE		; DO IT
0443+  F35F             
0444+  F35F 3A 44 FD    	LD	A,(HSTDSK)		; HSTDSK -> HEAD BIT 4 TO SELECT UNIT
0445+  F362 E6 0F       	AND	0FH
0446+  F364 FE 00       	CP	0
0447+  F366 CA 71 F3    	JP	Z,PPIDE_SETUP_UNIT0
0448+  F369 FE 01       	CP	1
0449+  F36B CA 77 F3    	JP	Z,PPIDE_SETUP_UNIT1
0450+  F36E CD 23 FC    	CALL	PANIC
0451+  F371             PPIDE_SETUP_UNIT0:
0452+  F371 3A B7 F1    	LD	A,(PPIDE_UNIT0)
0453+  F374 C3 7D F3    	JP	PPIDE_SETUP1
0454+  F377             PPIDE_SETUP_UNIT1:
0455+  F377 3A B8 F1    	LD	A,(PPIDE_UNIT1)
0456+  F37A C3 7D F3    	JP	PPIDE_SETUP1
0457+  F37D             PPIDE_SETUP1:
0458+  F37D 0E 0E       	LD	C,PPIDE_HEAD		; IDE HEAD REGISTER
0459+  F37F 32 EF F4    	LD	(PPIDEP_HEAD),A		; SAVE HEAD VALUE
0460+  F382 CD BD F3    	CALL	PPIDE_WRITE		; WRITE IT
0461+  F385             
0462+  F385             	; SEND 3 BYTES OF LBA (HSTTRK:HSTSEC) T:SS -> CYL:SEC (CC:S)
0463+  F385 3A 45 FD    	LD	A,(HSTTRK)		; HSTTRK LSB
0464+  F388 32 F0 F4    	LD	(PPIDEP_CYLHI),A	;   SAVE IT
0465+  F38B 0E 0D       	LD	C,PPIDE_CYL_MSB		;   IDE CYL MSB REGISTER
0466+  F38D CD BD F3    	CALL	PPIDE_WRITE		;   -> CYLINDER HI
0467+  F390 3A 48 FD    	LD	A,(HSTSEC + 1)		; HSTSEC MSB
0468+  F393 32 F1 F4    	LD	(PPIDEP_CYLLO),A	;   SAVE IT
0469+  F396 0E 0C       	LD	C,PPIDE_CYL_LSB		;   IDE CYL LSB REGISTER
0470+  F398 CD BD F3    	CALL	PPIDE_WRITE		;   -> CYLINDER HI
0471+  F39B 3A 47 FD    	LD	A,(HSTSEC)		; HSTSEC LSB
0472+  F39E 32 F2 F4    	LD	(PPIDEP_SEC),A		;   SAVE IT
0473+  F3A1 0E 0B       	LD	C,PPIDE_SECTOR		;   IDE CYL LSB REGISTER
0474+  F3A3 CD BD F3    	CALL	PPIDE_WRITE		;   -> CYLINDER HI
0475+  F3A6             
0476+  F3A6~            #IF (DSKYENABLE)
0477+  F3A6~            	CALL	PPIDE_DSKY
0478+  F3A6             #ENDIF
0479+  F3A6             
0480+  F3A6 C9          	RET
0481+  F3A7             ;
0482+  F3A7             ;
0483+  F3A7             ;
0484+  F3A7             PPIDE_READ:
0485+  F3A7             ;
0486+  F3A7             	; SET PPI MODE TO READ CONFIGURATION
0487+  F3A7 3E 92       	LD	A,RD_IDE_8255		; PPI MODE TO READ
0488+  F3A9 D3 83       	OUT	(PPICTL),A		; DO IT
0489+  F3AB             	RECOVERY			; OPTIONAL SMALL DELAY
0490+  F3AB             ;
0491+  F3AB             	; SELECT REQUESTED IDE REGISTER, THEN ASSERT READ
0492+  F3AB 79          	LD	A,C			; REGISTER SELECTION -> A
0493+  F3AC D3 82       	OUT	(IDECTL),A		; DO IT
0494+  F3AE             	RECOVERY			; OPTIONAL SMALL DELAY
0495+  F3AE F6 40       	OR	PPIDE_RD_LINE		; ASSERT READ
0496+  F3B0 D3 82       	OUT	(IDECTL),A		; DO IT
0497+  F3B2             	RECOVERY			; OPTIONAL SMALL DELAY
0498+  F3B2             ;
0499+  F3B2             	; READ THE BYTE
0500+  F3B2 DB 80       	IN	A,(IDELSB)		; READ LSB
0501+  F3B4             	RECOVERY			; OPTIONAL SMALL DELAY
0502+  F3B4 F5          	PUSH	AF			; SAVE IT FOR NOW
0503+  F3B5             ;
0504+  F3B5             ;	; DUMMY READ OF MSB
0505+  F3B5             ;	IN	A,(IDEMSB)		; READ LSB
0506+  F3B5             ;	RECOVERY			; OPTIONAL SMALL DELAY
0507+  F3B5             ;
0508+  F3B5             	; CLEAN UP AND RETURN
0509+  F3B5 79          	LD	A,C			; DEASSERT READ
0510+  F3B6 D3 82       	OUT	(IDECTL),A		; DO IT
0511+  F3B8 AF          	XOR	A			; RELEASE ALL BUS SIGNALS
0512+  F3B9 D3 82       	OUT	(IDECTL),A		; DO IT
0513+  F3BB             	RECOVERY			; OPTIONAL SMALL DELAY
0514+  F3BB             ;
0515+  F3BB F1          	POP	AF			; RECOVER THE DATA BYTE
0516+  F3BC C9          	RET				; RETURN
0517+  F3BD             ;
0518+  F3BD             ;
0519+  F3BD             ;
0520+  F3BD             PPIDE_WRITE:
0521+  F3BD             ;
0522+  F3BD             	; SAVE THE INCOMING VALUE TO WRITE
0523+  F3BD F5          	PUSH	AF
0524+  F3BE             ;
0525+  F3BE             	; SET PPI MODE TO WRITE CONFIGURATION
0526+  F3BE 3E 80       	LD	A,WR_IDE_8255		; PPI MODE TO WRITE
0527+  F3C0 D3 83       	OUT	(PPICTL),A		; DO IT
0528+  F3C2             	RECOVERY			; OPTIONAL SMALL DELAY
0529+  F3C2             ;
0530+  F3C2             	; SELECT REQUESTED IDE REGISTER
0531+  F3C2 79          	LD	A,C			; REGISTER SELECTION -> A
0532+  F3C3 D3 82       	OUT	(IDECTL),A		; DO IT
0533+  F3C5             	RECOVERY			; OPTIONAL SMALL DELAY
0534+  F3C5             
0535+  F3C5             	; SET THE VALUE TO WRITE
0536+  F3C5 F1          	POP	AF			; GET VALUE BACK
0537+  F3C6 D3 80       	OUT	(IDELSB),A		; SET IDE LSB
0538+  F3C8             	RECOVERY			; OPTIONAL SMALL DELAY
0539+  F3C8             ;
0540+  F3C8             ;	; MSB ALWAYS GETS ZERO
0541+  F3C8             ;	XOR	A			; ZERO A
0542+  F3C8             ;	OUT	(IDEMSB),A		; SET IDE MSB
0543+  F3C8             ;	RECOVERY			; OPTIONAL SMALL DELAY
0544+  F3C8             ;
0545+  F3C8             	; PULSE THE WRITE LINE
0546+  F3C8 79          	LD	A,C			; REGISTER SELECTION -> A
0547+  F3C9 F6 20       	OR	PPIDE_WR_LINE		; ASSERT WRITE
0548+  F3CB D3 82       	OUT	(IDECTL),A		; DO IT
0549+  F3CD             	RECOVERY			; OPTIONAL SMALL DELAY
0550+  F3CD 79          	LD	A,C
0551+  F3CE D3 82       	OUT	(IDECTL),A		; DO IT
0552+  F3D0             	RECOVERY			; OPTIONAL SMALL DELAY
0553+  F3D0             ;
0554+  F3D0             	; CLEAN UP AND RETURN
0555+  F3D0 AF          	XOR	A			; RELEASE ALL BUS SIGNALS
0556+  F3D1 D3 82       	OUT	(IDECTL),A		; DO IT
0557+  F3D3             	RECOVERY			; OPTIONAL SMALL DELAY
0558+  F3D3             ;
0559+  F3D3 C9          	RET				; RETURN
0560+  F3D4             ;
0561+  F3D4             ;
0562+  F3D4             ;
0563+  F3D4~            #IF (DSKYENABLE)
0564+  F3D4~            PPIDE_DSKY:
0565+  F3D4~            	LD	HL,DSKY_HEXBUF
0566+  F3D4~            	LD	A,(PPIDEP_HEAD)
0567+  F3D4~            	LD	(HL),A
0568+  F3D4~            	INC	HL
0569+  F3D4~            	LD	A,(PPIDEP_CYLHI)
0570+  F3D4~            	LD	(HL),A
0571+  F3D4~            	INC	HL
0572+  F3D4~            	LD	A,(PPIDEP_CYLLO)
0573+  F3D4~            	LD	(HL),A
0574+  F3D4~            	INC	HL
0575+  F3D4~            	LD	A,(PPIDEP_SEC)
0576+  F3D4~            	LD	(HL),A
0577+  F3D4~            	CALL	DSKY_HEXOUT
0578+  F3D4~            	RET
0579+  F3D4             #ENDIF
0580+  F3D4             ;
0581+  F3D4             ;
0582+  F3D4             ;
0583+  F3D4             PPIDE_PRT:
0584+  F3D4 CD 91 FB    	CALL	NEWLINE
0585+  F3D7             
0586+  F3D7 11 8A F4    	LD	DE,PPIDESTR_PREFIX
0587+  F3DA CD 13 FC    	CALL	WRITESTR
0588+  F3DD             
0589+  F3DD CD 4B FB    	CALL	PC_SPACE
0590+  F3E0 11 91 F4    	LD	DE,PPIDESTR_CMD
0591+  F3E3 CD 13 FC    	CALL	WRITESTR
0592+  F3E6 3A EE F4    	LD	A,(PPIDEP_CMD)
0593+  F3E9 CD C3 FB    	CALL	PRTHEXBYTE
0594+  F3EC             
0595+  F3EC CD 4B FB    	CALL	PC_SPACE
0596+  F3EF CD 5F FB    	CALL	PC_LBKT
0597+  F3F2 3A EE F4    	LD	A,(PPIDEP_CMD)
0598+  F3F5 11 9E F4    	LD	DE,PPIDESTR_READ
0599+  F3F8 FE 20       	CP	PPIDE_CMDREAD
0600+  F3FA CA 08 F4    	JP	Z,PPIDE_PRTCMD
0601+  F3FD 11 A3 F4    	LD	DE,PPIDESTR_WRITE
0602+  F400 FE 30       	CP	PPIDE_CMDWRITE
0603+  F402 CA 08 F4    	JP	Z,PPIDE_PRTCMD
0604+  F405 11 A9 F4    	LD	DE,PPIDESTR_UNKCMD
0605+  F408             PPIDE_PRTCMD:
0606+  F408 CD 13 FC    	CALL	WRITESTR
0607+  F40B CD 64 FB    	CALL	PC_RBKT
0608+  F40E             
0609+  F40E CD 4B FB    	CALL	PC_SPACE
0610+  F411 3A EF F4    	LD	A,(PPIDEP_HEAD)
0611+  F414 CD C3 FB    	CALL	PRTHEXBYTE
0612+  F417 3A F0 F4    	LD	A,(PPIDEP_CYLHI)
0613+  F41A CD C3 FB    	CALL	PRTHEXBYTE
0614+  F41D 3A F1 F4    	LD	A,(PPIDEP_CYLLO)
0615+  F420 CD C3 FB    	CALL	PRTHEXBYTE
0616+  F423 3A F2 F4    	LD	A,(PPIDEP_SEC)
0617+  F426 CD C3 FB    	CALL	PRTHEXBYTE
0618+  F429             
0619+  F429 CD 4B FB    	CALL	PC_SPACE
0620+  F42C 11 9A F4    	LD	DE,PPIDESTR_ARROW
0621+  F42F CD 13 FC    	CALL	WRITESTR
0622+  F432             
0623+  F432 CD 4B FB    	CALL	PC_SPACE
0624+  F435 0E 0F       	LD	C,PPIDE_STTS		; IDE STATUS REGISTER
0625+  F437 CD A7 F3    	CALL	PPIDE_READ		; READ IT
0626+  F43A CD C3 FB    	CALL	PRTHEXBYTE
0627+  F43D             
0628+  F43D CD 4B FB    	CALL	PC_SPACE
0629+  F440 0E 09       	LD	C,PPIDE_ERROR		; IDE ERROR REGISTER
0630+  F442 CD A7 F3    	CALL	PPIDE_READ		; READ IT
0631+  F445 CD C3 FB    	CALL	PRTHEXBYTE
0632+  F448             
0633+  F448 CD 4B FB    	CALL	PC_SPACE
0634+  F44B 11 96 F4    	LD	DE,PPIDESTR_RC
0635+  F44E CD 13 FC    	CALL	WRITESTR
0636+  F451 3A ED F4    	LD	A,(PPIDE_RC)
0637+  F454 CD C3 FB    	CALL	PRTHEXBYTE
0638+  F457             
0639+  F457 CD 4B FB    	CALL	PC_SPACE
0640+  F45A CD 5F FB    	CALL	PC_LBKT
0641+  F45D 3A ED F4    	LD	A,(PPIDE_RC)
0642+  F460 11 B0 F4    	LD	DE,PPIDESTR_RCOK
0643+  F463 FE 00       	CP	PPIDE_RCOK
0644+  F465 CA 83 F4    	JP	Z,PPIDE_PRTRC
0645+  F468 11 B3 F4    	LD	DE,PPIDESTR_RCCMDERR
0646+  F46B FE 01       	CP	PPIDE_RCCMDERR
0647+  F46D CA 83 F4    	JP	Z,PPIDE_PRTRC
0648+  F470 11 C1 F4    	LD	DE,PPIDESTR_RCRDYTO
0649+  F473 FE 02       	CP	PPIDE_RCRDYTO
0650+  F475 CA 83 F4    	JP	Z,PPIDE_PRTRC
0651+  F478 11 CF F4    	LD	DE,PPIDESTR_RCBUFTO
0652+  F47B FE 03       	CP	PPIDE_RCBUFTO
0653+  F47D CA 83 F4    	JP	Z,PPIDE_PRTRC
0654+  F480 11 DE F4    	LD	DE,PPIDESTR_RCUNK
0655+  F483             PPIDE_PRTRC:
0656+  F483 CD 13 FC    	CALL	WRITESTR
0657+  F486 CD 64 FB    	CALL	PC_RBKT
0658+  F489             
0659+  F489 C9          	RET
0660+  F48A             ;
0661+  F48A             ;
0662+  F48A             ;
0663+  F48A 50 50 49 44 PPIDESTR_PREFIX		.TEXT	"PPIDE:$"
0663+  F48E 45 3A 24 
0664+  F491 43 4D 44 3D PPIDESTR_CMD		.TEXT	"CMD=$"
0664+  F495 24 
0665+  F496 52 43 3D 24 PPIDESTR_RC		.TEXT	"RC=$"
0666+  F49A 2D 2D 3E 24 PPIDESTR_ARROW		.TEXT	"-->$"
0667+  F49E 52 45 41 44 PPIDESTR_READ		.TEXT	"READ$"
0667+  F4A2 24 
0668+  F4A3 57 52 49 54 PPIDESTR_WRITE		.TEXT	"WRITE$"
0668+  F4A7 45 24 
0669+  F4A9 55 4E 4B 43 PPIDESTR_UNKCMD		.TEXT	"UNKCMD$"
0669+  F4AD 4D 44 24 
0670+  F4B0 4F 4B 24    PPIDESTR_RCOK		.TEXT	"OK$"
0671+  F4B3 43 4F 4D 4D PPIDESTR_RCCMDERR	.TEXT	"COMMAND ERROR$"
0671+  F4B7 41 4E 44 20 
0671+  F4BB 45 52 52 4F 
0671+  F4BF 52 24 
0672+  F4C1 52 45 41 44 PPIDESTR_RCRDYTO	.TEXT	"READY TIMEOUT$"
0672+  F4C5 59 20 54 49 
0672+  F4C9 4D 45 4F 55 
0672+  F4CD 54 24 
0673+  F4CF 42 55 46 46 PPIDESTR_RCBUFTO	.TEXT	"BUFFER TIMEOUT$"
0673+  F4D3 45 52 20 54 
0673+  F4D7 49 4D 45 4F 
0673+  F4DB 55 54 24 
0674+  F4DE 55 4E 4B 4E PPIDESTR_RCUNK		.TEXT	"UNKNOWN ERROR$"
0674+  F4E2 4F 57 4E 20 
0674+  F4E6 45 52 52 4F 
0674+  F4EA 52 24 
0675+  F4EC             ;
0676+  F4EC             ;==================================================================================================
0677+  F4EC             ;   PPIDE DISK DRIVER - DATA
0678+  F4EC             ;==================================================================================================
0679+  F4EC             ;
0680+  F4EC 00          PPIDE_STAT	.DB	0
0681+  F4ED 00          PPIDE_RC	.DB	0
0682+  F4EE             ;
0683+  F4EE             ; PPIDE PARAMETERS
0684+  F4EE             ;
0685+  F4EE 00          PPIDEP_CMD	.DB	0
0686+  F4EF 00          PPIDEP_HEAD	.DB	0
0687+  F4F0 00          PPIDEP_CYLHI	.DB	0
0688+  F4F1 00          PPIDEP_CYLLO	.DB	0
0689+  F4F2 00          PPIDEP_SEC	.DB	0
0690+  F4F3 00          PPIDEP_STTS	.DB	0
0691+  F4F4 00          PPIDEP_ERR	.DB	0
0692+  F4F5             ;
0693+  F4F5             ; Error Register (ERR bit being set in the Status Register)
0694+  F4F5             ;
0695+  F4F5             ; Bit 7: BBK (Bad Block Detected) Set when a Bad Block is detected.
0696+  F4F5             ; Bit 6: UNC (Uncorrectable Data Error) Set when Uncorrectable Error is encountered.
0697+  F4F5             ; Bit 5: MC (Media Changed) Set to 0.
0698+  F4F5             ; Bit 4: IDNF (ID Not Found) Set when Sector ID not found.
0699+  F4F5             ; Bit 3: MCR (Media Change Request) Set to 0.
0700+  F4F5             ; Bit 2: ABRT (Aborted Command) Set when Command Aborted due to drive error.
0701+  F4F5             ; Bit 1: TKONF (Track 0 Not Found) Set when Executive Drive Diagnostic Command.
0702+  F4F5             ; Bit 0: AMNF (Address mark Not Found) Set in case of a general error.
0703+  F4F5             ;
0704+  F4F5             ; Status Register (When the contents of this register are read by the host, the IREQ# bit is cleared)
0705+  F4F5             ;
0706+  F4F5             ; Bit 7: BSY (Busy) Set when the drive is busy and unable to process any new ATA commands.
0707+  F4F5             ; Bit 6: DRDY (Data Ready) Set when the device is ready to accept ATA commands from the host.
0708+  F4F5             ; Bit 5: DWF (Drive Write Fault) Always set to 0.
0709+  F4F5             ; Bit 4: DSC (Drive Seek Complete) Set when the drive heads have been positioned over a specific track.
0710+  F4F5             ; Bit 3: DRQ (Data Request) Set when device is ready to transfer a word or byte of data to or from the host and the device.
0711+  F4F5             ; Bit 2: CORR (Corrected Data) Always set to 0.
0712+  F4F5             ; Bit 1: IDX (Index) Always set to 0.
0713+  F4F5             ; Bit 0: ERR (Error) Set when an error occurred during the previous ATA command.
0341   F4F5             SIZ_PPIDE	.EQU	$ - ORG_PPIDE
0342   F4F5             		.ECHO	"PPIDE occupies "
0343   F4F5             		.ECHO	SIZ_PPIDE
0344   F4F5             		.ECHO	" bytes.\n"
0345   F4F5             #ENDIF
0346   F4F5             ;
0347   F4F5             #IF (SDENABLE)
0348   F4F5             ORG_SD		.EQU	$
0349   F4F5               #INCLUDE "sd.asm"
0001+  F4F5             ;
0002+  F4F5             ;=============================================================================
0003+  F4F5             ;   SD/SDHC/SDXC CARD STORAGE DRIVER
0004+  F4F5             ;=============================================================================
0005+  F4F5             ;
0006+  F4F5             ;------------------------------------------------------------------------------
0007+  F4F5             ; SD Signal	Active	JUHA	N8	CSIO	PPI	UART	DSD    MK4
0008+  F4F5             ; ------------	-------	-------	-------	-------	-------	-------	-------	-------
0009+  F4F5             ; CS (DAT3)	LO ->	RTC:2	RTC:2	RTC:2	~PC:4	MCR:3	OPR:2  MK4_SD:2
0010+  F4F5             ; CLK		HI ->	RTC:1	RTC:1	N/A	PC:1	~MCR:2	OPR:1  N/A
0011+  F4F5             ; DI (CMD)	HI ->	RTC:0	RTC:0	N/A	PC:0	~MCR:0	OPR:0  N/A
0012+  F4F5             ; DO (DAT0)	HI ->	RTC:7	RTC:6	N/A	PB:7	~MSR:5	OPR:0  N/A
0013+  F4F5             ;------------------------------------------------------------------------------
0014+  F4F5             ;
0015+  F4F5             ; CS = CHIP SELECT (AKA DAT3 FOR NON-SPI MODE)
0016+  F4F5             ; CLK = CLOCK
0017+  F4F5             ; DI = DATA IN (HOST -> CARD, AKA CMD FOR NON-SPI MODE)
0018+  F4F5             ; DO = DATA OUT (HOST <- CARD, AKA DAT0 FOR NON-SPI MODE)
0019+  F4F5             ;
0020+  F4F5             ; NOTES:
0021+  F4F5             ;   1) SIGNAL NAMES ARE FROM THE SD CARD SPEC AND ARE NAMED FROM THE
0022+  F4F5             ;      PERSPECTIVE OF THE SD CARD:
0023+  F4F5             ;        DI = DATA IN: HOST -> CARD = MOSI (MASTER OUT/SLAVE IN)
0024+  F4F5             ;        DO = DATA OUT: HOST <- CARD = MISO (MASTER IN/SLAVE OUT)
0025+  F4F5             ;
0026+  F4F5             ;   2) THE QUIESCENT STATE OF THE OUTPUT SIGNALS (HOST -> CARD) IS:
0027+  F4F5             ;      CS = HI (NOT SELECTED)
0028+  F4F5             ;      CLK = LO (HI FOR CSIO)
0029+  F4F5             ;      DI = HI (ACTIVE IS THE NATURAL/DEFAULT STATE FOR DATA IN)
0030+  F4F5             ;
0031+  F4F5             ;   3) SPI MODE 0 IMPLEMENTATION IS USED (CPOL=0, CPHA=0)
0032+  F4F5             ;      THE DATA MUST BE AVAILABLE BEFORE THE FIRST CLOCK SIGNAL RISING.
0033+  F4F5             ;      THE CLOCK IDLE STATE IS ZERO. THE DATA ON MISO AND MOSI LINES 
0034+  F4F5             ;      MUST BE STABLE WHILE THE CLOCK IS HIGH AND CAN BE CHANGED WHEN
0035+  F4F5             ;      THE CLOCK IS LOW. THE DATA IS CAPTURED ON THE CLOCK'S LOW-TO-HIGH
0036+  F4F5             ;      TRANSITION AND PROPAGATED ON HIGH-TO-LOW CLOCK TRANSITION.
0037+  F4F5             ;
0038+  F4F5             ;      NOTE: THE CSIO IMPLEMENTATION (INCLUDE MK4) USES SPI MODE 4
0039+  F4F5             ;      (CPOL=1, CPHA=1) BECAUSE THAT IS THE WAY THAT THE Z180 CSIO
0040+  F4F5             ;      INTERFACE WORKS.  ALL OF THE CLOCK TRANSITIONS LISTED ABOVE
0041+  F4F5             ;      ARE REVERSED FOR CSIO.
0042+  F4F5             ;
0043+  F4F5             ;   4) DI SHOULD BE LEFT HI (ACTIVE) WHENEVER UNUSED (FOR EXAMPLE, WHEN
0044+  F4F5             ;      HOST IS RECEIVING DATA (HOST <- CARD)).
0045+  F4F5             ;
0046+  F4F5~            #IF (SDMODE == SDMODE_JUHA)		; JUHA MINI-BOARD
0047+  F4F5~            SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0048+  F4F5~            SD_OPRREG	.EQU	RTC		; USES RTC LATCHES FOR OPERATION
0049+  F4F5~            SD_OPRDEF	.EQU	%00000001	; QUIESCENT STATE???
0050+  F4F5~            SD_INPREG	.EQU	RTC		; INPUT REGISTER IS RTC
0051+  F4F5~            SD_CS		.EQU	%00000100	; RTC:2 IS SELECT
0052+  F4F5~            SD_CLK		.EQU	%00000010	; RTC:1 IS CLOCK
0053+  F4F5~            SD_DI		.EQU	%00000001	; RTC:0 IS DATA IN (CARD <- CPU)
0054+  F4F5~            SD_DO		.EQU	%10000000	; RTC:7 IS DATA OUT (CARD -> CPU)
0055+  F4F5             #ENDIF
0056+  F4F5             ;
0057+  F4F5~            #IF (SDMODE == SDMODE_N8)		; UNMODIFIED N8-2511
0058+  F4F5~            SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0059+  F4F5~            SD_OPRREG	.EQU	RTC		; USES RTC LATCHES FOR OPERATION
0060+  F4F5~            SD_OPRDEF	.EQU	%00000001	; QUIESCENT STATE???
0061+  F4F5~            SD_INPREG	.EQU	RTC		; INPUT REGISTER IS RTC
0062+  F4F5~            SD_CS		.EQU	%00000100	; RTC:2 IS SELECT
0063+  F4F5~            SD_CLK		.EQU	%00000010	; RTC:1 IS CLOCK
0064+  F4F5~            SD_DI		.EQU	%00000001	; RTC:0 IS DATA IN (CARD <- CPU)
0065+  F4F5~            SD_DO		.EQU	%01000000	; RTC:6 IS DATA OUT (CARD -> CPU)
0066+  F4F5             #ENDIF
0067+  F4F5             ;
0068+  F4F5~            #IF (SDMODE == SDMODE_CSIO)		; N8-2312
0069+  F4F5~            SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0070+  F4F5~            SD_OPRREG	.EQU	RTC		; USES RTC LATCHES FOR OPERATION
0071+  F4F5~            SD_OPRDEF	.EQU	%00000000	; QUIESCENT STATE
0072+  F4F5~            SD_CS		.EQU	%00000100	; RTC:2 IS SELECT
0073+  F4F5~            SD_CNTR		.EQU	CPU_CNTR
0074+  F4F5~            SD_TRDR		.EQU	CPU_TRDR
0075+  F4F5             #ENDIF
0076+  F4F5             ;
0077+  F4F5~            #IF (SDMODE == SDMODE_PPI)		; PPISD
0078+  F4F5~            SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0079+  F4F5~            SD_PPIBASE	.EQU	PPIBASE		; BASE IO PORT FOR PPI
0080+  F4F5~            SD_PPIB		.EQU	PPIBASE + 1	; PPI PORT B (INPUT: DOUT)
0081+  F4F5~            SD_PPIC		.EQU	PPIBASE + 2	; PPI PORT C (OUTPUT: CS, CLK, DIN)
0082+  F4F5~            SD_PPIX		.EQU	PPIBASE + 3	; PPI CONTROL PORT
0083+  F4F5~            SD_OPRREG	.EQU	SD_PPIC		; PPI PORT C IS OPR REG
0084+  F4F5~            SD_OPRDEF	.EQU	%00110001	; CS HI, DI HI
0085+  F4F5~            SD_INPREG	.EQU	SD_PPIB		; INPUT REGISTER IS PPI PORT B
0086+  F4F5~            SD_CS		.EQU	%00010000	; PPIC:4 IS SELECT
0087+  F4F5~            SD_CLK		.EQU	%00000010	; PPIC:1 IS CLOCK
0088+  F4F5~            SD_DI		.EQU	%00000001	; PPIC:0 IS DATA IN (CARD <- CPU)
0089+  F4F5~            SD_DO		.EQU	%10000000	; PPIB:7 IS DATA OUT (CARD -> CPU)
0090+  F4F5             #ENDIF
0091+  F4F5             ;
0092+  F4F5             #IF (SDMODE == SDMODE_UART)
0093+  F4F5             SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0094+  F4F5             SD_OPRREG	.EQU	SIO_MCR		; UART MCR PORT (OUTPUT: CS, CLK, DIN)
0095+  F4F5             SD_OPRDEF	.EQU	%00001100	; QUIESCENT STATE
0096+  F4F5             SD_INPREG	.EQU	SIO_MSR		; INPUT REGISTER IS MSR
0097+  F4F5             SD_CS		.EQU	%00001000	; UART MCR:3 IS SELECT
0098+  F4F5             SD_CLK		.EQU	%00000100	; UART MCR:2 IS CLOCK
0099+  F4F5             SD_DI		.EQU	%00000001	; UART MCR:0 IS DATA IN (CARD <- CPU)
0100+  F4F5             SD_DO		.EQU	%00100000	; UART MSR:5 IS DATA OUT (CARD -> CPU)
0101+  F4F5             #ENDIF
0102+  F4F5             ;
0103+  F4F5~            #IF (SDMODE == SDMODE_DSD)		; DUAL SD
0104+  F4F5~            SD_UNITCNT	.EQU	2		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0105+  F4F5~            SD_OPRREG	.EQU	$08		; DEDICATED OPERATIONS REGISTER
0106+  F4F5~            SD_OPRDEF	.EQU	%00000001	; QUIESCENT STATE
0107+  F4F5~            SD_INPREG	.EQU	SD_OPRREG	; INPUT REGISTER IS OPRREG
0108+  F4F5~            SD_SELREG	.EQU	SD_OPRREG + 1	; DEDICATED SELECTION REGISTER
0109+  F4F5~            SD_SELDEF	.EQU	%00000000	; SELECTION REGISTER DEFAULT
0110+  F4F5~            SD_CS		.EQU	%00000100	; RTC:2 IS SELECT
0111+  F4F5~            SD_CLK		.EQU	%00000010	; RTC:1 IS CLOCK
0112+  F4F5~            SD_DI		.EQU	%00000001	; RTC:6 IS DATA IN (CARD <- CPU)
0113+  F4F5~            SD_DO		.EQU	%00000001	; RTC:0 IS DATA OUT (CARD -> CPU)
0114+  F4F5             #ENDIF
0115+  F4F5             ;
0116+  F4F5~            #IF (SDMODE == SDMODE_MK4)		; MARK IV (CSIO STYLE INTERFACE)
0117+  F4F5~            SD_UNITCNT	.EQU	1		; NUMBER OF PHYSICAL UNITS (SOCKETS)
0118+  F4F5~            SD_OPRREG	.EQU	MK4_SD		; DEDICATED MK4 SDCARD REGISTER
0119+  F4F5~            SD_OPRDEF	.EQU	%00000000	; QUIESCENT STATE
0120+  F4F5~            SD_CS		.EQU	%00000100	; SELECT ACTIVE
0121+  F4F5~            SD_CNTR		.EQU	CPU_CNTR
0122+  F4F5~            SD_TRDR		.EQU	CPU_TRDR
0123+  F4F5             #ENDIF
0124+  F4F5             ;
0125+  F4F5             ; SD CARD COMMANDS
0126+  F4F5             ;
0127+  F4F5             SD_CMD0		.EQU	$40 | 0		; 0x40, GO_IDLE_STATE
0128+  F4F5             SD_CMD1		.EQU	$40 | 1		; 0x41, SEND_OP_COND
0129+  F4F5             SD_CMD8		.EQU	$40 | 8		; 0x48, SEND_IF_COND
0130+  F4F5             SD_CMD9		.EQU	$40 | 9		; 0x49, SEND_CSD
0131+  F4F5             SD_CMD10	.EQU	$40 | 10	; 0x4A, SEND_CID
0132+  F4F5             SD_CMD16	.EQU	$40 | 16	; 0x50, SET_BLOCKLEN
0133+  F4F5             SD_CMD17	.EQU	$40 | 17	; 0x51, READ_SINGLE_BLOCK
0134+  F4F5             SD_CMD24	.EQU	$40 | 24	; 0x58, WRITE_BLOCK
0135+  F4F5             SD_CMD55	.EQU	$40 | 55	; 0x77, APP_CMD
0136+  F4F5             SD_CMD58	.EQU	$40 | 58	; 0x7A, READ_OCR
0137+  F4F5             ; SD APPLICATION SPECIFIC COMMANDS
0138+  F4F5             SD_ACMD41	.EQU	$40 | 41	; 0x69, SD_APP_OP_COND
0139+  F4F5             ;
0140+  F4F5             ; SD CARD TYPE
0141+  F4F5             ;
0142+  F4F5             SD_TYPEUNK	.EQU	0	; CARD TYPE UNKNOWN/UNDETERMINED
0143+  F4F5             SD_TYPEMMC	.EQU	1	; MULTIMEDIA CARD (MMC STANDARD)
0144+  F4F5             SD_TYPESDSC	.EQU	2	; SDSC CARD (V1)
0145+  F4F5             SD_TYPESDHC	.EQU	3	; SDHC/SDXC CARD (V2)
0146+  F4F5             ;
0147+  F4F5             ; SD CARD STATUS (SD_STAT)
0148+  F4F5             ;
0149+  F4F5             SD_STOK		.EQU	0	; OK
0150+  F4F5             SD_STNOTRDY	.EQU	-1	; NOT READY (INITIALIZATION PENDING)
0151+  F4F5             SD_STRDYTO	.EQU	-2	; TIMEOUT WAITING FOR CARD TO BE READY
0152+  F4F5             SD_STINITTO	.EQU	-3	; INITIALIZATOIN TIMEOUT
0153+  F4F5             SD_STCMDTO	.EQU	-4	; TIMEOUT WAITING FOR COMMAND RESPONSE
0154+  F4F5             SD_STCMDERR	.EQU	-5	; COMMAND ERROR OCCURRED (REF SD_RC)
0155+  F4F5             SD_STDATAERR	.EQU	-6	; DATA ERROR OCCURRED (REF SD_TOK)
0156+  F4F5             SD_STDATATO	.EQU	-7	; DATA TRANSFER TIMEOUT
0157+  F4F5             SD_STCRCERR	.EQU	-8	; CRC ERROR ON RECEIVED DATA PACKET
0158+  F4F5             SD_STNOMEDIA	.EQU	-9	; NO MEDIA IN CONNECTOR
0159+  F4F5             SD_STWRTPROT	.EQU	-10	; ATTEMPT TO WRITE TO WRITE PROTECTED MEDIA
0160+  F4F5             ;
0161+  F4F5             ;
0162+  F4F5             ;
0163+  F4F5             SD_DISPATCH:
0164+  F4F5 78          	LD	A,B		; GET REQUESTED FUNCTION
0165+  F4F6 E6 0F       	AND	$0F
0166+  F4F8 CA 93 F5    	JP	Z,SD_READ
0167+  F4FB 3D          	DEC	A
0168+  F4FC CA 9B F5    	JP	Z,SD_WRITE
0169+  F4FF 3D          	DEC	A
0170+  F500 CA 8A F5    	JP	Z,SD_STATUS
0171+  F503 3D          	DEC	A
0172+  F504 CA 0A F5    	JP	Z,SD_MEDIA
0173+  F507 CD 23 FC    	CALL	PANIC
0174+  F50A             ;
0175+  F50A             ;
0176+  F50A             ;
0177+  F50A             SD_MEDIA:
0178+  F50A CD B6 F5    	CALL	SD_SELUNIT
0179+  F50D             ;
0180+  F50D             	; INITIALIZE THE SD CARD TO ACCOMMODATE HOT SWAPPING
0181+  F50D CD 31 F7    	CALL	SD_INITCARD
0182+  F510 3E 03       	LD	A,MID_HD	; ASSUME SUCCESS
0183+  F512 C8          	RET	Z		; RETURN IF GOOD INIT
0184+  F513 CD A9 F5    	CALL	SD_PRT
0185+  F516 3E 00       	LD	A,MID_NONE	; IF FAILURE, RETURN NO MEDIA
0186+  F518 C9          	RET
0187+  F519             ;
0188+  F519             SD_INIT:
0189+  F519 CD AC FB    	PRTS("SD:$")
0189+  F51C 53 44 3A 24 
0190+  F520 CD AC FB    	PRTS(" UNITS=$")
0190+  F523 20 55 4E 49 
0190+  F527 54 53 3D 24 
0191+  F52B 3E 01       	LD	A,SD_UNITCNT
0192+  F52D CD C3 FB    	CALL	PRTHEXBYTE
0193+  F530~            #IF (SDMODE == SDMODE_JUHA)
0194+  F530~            	PRTS(" MODE=JUHA$")
0194+  F530~            	PRTS(" MODE=JUHA$")
0195+  F530~            	PRTS(" IO=0x$")
0195+  F530~            	PRTS(" IO=0x$")
0196+  F530~            	LD	A,SD_OPRREG
0197+  F530~            	CALL	PRTHEXBYTE
0198+  F530             #ENDIF
0199+  F530             ;
0200+  F530~            #IF (SDMODE == SDMODE_N8)
0201+  F530~            	PRTS(" MODE=N8$")
0201+  F530~            	PRTS(" MODE=N8$")
0202+  F530~            	PRTS(" IO=0x$")
0202+  F530~            	PRTS(" IO=0x$")
0203+  F530~            	LD	A,SD_OPRREG
0204+  F530~            	CALL	PRTHEXBYTE
0205+  F530             #ENDIF
0206+  F530             ;
0207+  F530~            #IF (SDMODE == SDMODE_CSIO)
0208+  F530~            	PRTS(" MODE=CSIO$")
0208+  F530~            	PRTS(" MODE=CSIO$")
0209+  F530~              #IF (SDCSIOFAST)
0210+  F530~            	PRTS(" FAST$")
0210+  F530~            	PRTS(" FAST$")
0211+  F530~              #ENDIF
0212+  F530~            	PRTS(" OPR=0x$")
0212+  F530~            	PRTS(" OPR=0x$")
0213+  F530~            	LD	A,SD_OPRREG
0214+  F530~            	CALL	PRTHEXBYTE
0215+  F530~            	PRTS(" CNTR=0x$")
0215+  F530~            	PRTS(" CNTR=0x$")
0216+  F530~            	LD	A,SD_CNTR
0217+  F530~            	CALL	PRTHEXBYTE
0218+  F530~            	PRTS(" TRDR=0x$")
0218+  F530~            	PRTS(" TRDR=0x$")
0219+  F530~            	LD	A,SD_TRDR
0220+  F530~            	CALL	PRTHEXBYTE
0221+  F530             #ENDIF
0222+  F530             ;
0223+  F530~            #IF (SDMODE == SDMODE_PPI)
0224+  F530~            	PRTS(" MODE=PPI$")
0224+  F530~            	PRTS(" MODE=PPI$")
0225+  F530~            	PRTS(" BASEIO=0x$")
0225+  F530~            	PRTS(" BASEIO=0x$")
0226+  F530~            	LD	A,SD_PPIBASE
0227+  F530~            	CALL	PRTHEXBYTE
0228+  F530             #ENDIF
0229+  F530             ;
0230+  F530             #IF (SDMODE == SDMODE_UART)
0231+  F530 CD AC FB    	PRTS(" MODE=UART$")
0231+  F533 20 4D 4F 44 
0231+  F537 45 3D 55 41 
0231+  F53B 52 54 24 
0232+  F53E CD AC FB    	PRTS(" MCR=0x$")
0232+  F541 20 4D 43 52 
0232+  F545 3D 30 78 24 
0233+  F549 3E 94       	LD	A,SIO_MCR
0234+  F54B CD C3 FB    	CALL	PRTHEXBYTE
0235+  F54E CD AC FB    	PRTS(" MSR=0x$")
0235+  F551 20 4D 53 52 
0235+  F555 3D 30 78 24 
0236+  F559 3E 96       	LD	A,SIO_MSR
0237+  F55B CD C3 FB    	CALL	PRTHEXBYTE
0238+  F55E             #ENDIF
0239+  F55E             ;
0240+  F55E~            #IF (SDMODE == SDMODE_DSD)
0241+  F55E~            	PRTS(" MODE=DSD$")
0241+  F55E~            	PRTS(" MODE=DSD$")
0242+  F55E~            	PRTS(" OPR=0x$")
0242+  F55E~            	PRTS(" OPR=0x$")
0243+  F55E~            	LD	A,SD_OPRREG
0244+  F55E~            	CALL	PRTHEXBYTE
0245+  F55E~            	PRTS(" SEL=0x$")
0245+  F55E~            	PRTS(" SEL=0x$")
0246+  F55E~            	LD	A,SD_SELREG
0247+  F55E~            	CALL	PRTHEXBYTE
0248+  F55E             #ENDIF
0249+  F55E             ;
0250+  F55E~            #IF (SDMODE == SDMODE_MK4)
0251+  F55E~            	PRTS(" MODE=MK4$")
0251+  F55E~            	PRTS(" MODE=MK4$")
0252+  F55E~              #IF (SDCSIOFAST)
0253+  F55E~            	PRTS(" FAST$")
0253+  F55E~            	PRTS(" FAST$")
0254+  F55E~              #ENDIF
0255+  F55E~            	PRTS(" OPR=0x$")
0255+  F55E~            	PRTS(" OPR=0x$")
0256+  F55E~            	LD	A,SD_OPRREG
0257+  F55E~            	CALL	PRTHEXBYTE
0258+  F55E~            	PRTS(" CNTR=0x$")
0258+  F55E~            	PRTS(" CNTR=0x$")
0259+  F55E~            	LD	A,SD_CNTR
0260+  F55E~            	CALL	PRTHEXBYTE
0261+  F55E~            	PRTS(" TRDR=0x$")
0261+  F55E~            	PRTS(" TRDR=0x$")
0262+  F55E~            	LD	A,SD_TRDR
0263+  F55E~            	CALL	PRTHEXBYTE
0264+  F55E             #ENDIF
0265+  F55E             ;
0266+  F55E 3E FF       	LD	A,SD_STNOTRDY
0267+  F560 21 2A FB    	LD	HL,SD_STATLST
0268+  F563 22 2B FB    	LD	(SD_STATPTR),HL
0269+  F566 77          	LD	(HL),A
0270+  F567 23          	INC	HL
0271+  F568 77          	LD	(HL),A
0272+  F569 3E 00       	LD	A,SD_TYPEUNK
0273+  F56B 21 2D FB    	LD	HL,SD_TYPELST
0274+  F56E 22 2E FB    	LD	(SD_TYPEPTR),HL
0275+  F571 77          	LD	(HL),A
0276+  F572 23          	INC	HL
0277+  F573 77          	LD	(HL),A
0278+  F574             ;
0279+  F574 06 01       	LD	B,SD_UNITCNT
0280+  F576 0E 00       	LD	C,0
0281+  F578             SD_INIT1:
0282+  F578 C5          	PUSH	BC
0283+  F579 CD B6 F5    	CALL	SD_SELUNIT
0284+  F57C CD 31 F7    	CALL	SD_INITCARD
0285+  F57F CD A9 F5    	CALL	SD_PRT
0286+  F582 CC EF F7    	CALL	Z,SD_PRTINFO
0287+  F585 C1          	POP	BC
0288+  F586 0C          	INC	C
0289+  F587 10 EF       	DJNZ	SD_INIT1
0290+  F589             ;
0291+  F589 C9          	RET
0292+  F58A             ;
0293+  F58A             SD_STATUS:
0294+  F58A CD B6 F5    	CALL	SD_SELUNIT
0295+  F58D 2A 2B FB    	LD	HL,(SD_STATPTR)
0296+  F590 7E          	LD	A,(HL)
0297+  F591 B7          	OR	A
0298+  F592 C9          	RET
0299+  F593             ;
0300+  F593             SD_READ:
0301+  F593 CD B6 F5    	CALL	SD_SELUNIT
0302+  F596 CD F1 F8    	CALL	SD_RDSEC
0303+  F599 18 0E       	JR	SD_PRT
0304+  F59B             ;
0305+  F59B             SD_WRITE:
0306+  F59B CD B6 F5    	CALL	SD_SELUNIT
0307+  F59E CD F6 F5    	CALL	SD_CHKWP
0308+  F5A1 C4 85 F9    	CALL	NZ,SD_WRTPROT
0309+  F5A4 CC 14 F9    	CALL	Z,SD_WRSEC
0310+  F5A7 18 00       	JR	SD_PRT
0311+  F5A9             ;
0312+  F5A9             SD_PRT:
0313+  F5A9             #IF (SDTRACE >= 1)
0314+  F5A9 C8          	RET	Z
0315+  F5AA F5          	PUSH	AF
0316+  F5AB CD 91 F9    	CALL	SD_PRTPREFIX
0317+  F5AE CD 4B FB    	CALL	PC_SPACE
0318+  F5B1 CD A8 F9    	CALL	SD_PRTSTAT
0319+  F5B4 F1          	POP	AF
0320+  F5B5             #ENDIF
0321+  F5B5 C9          	RET
0322+  F5B6             ;
0323+  F5B6             ;=============================================================================
0324+  F5B6             ; SD HARDWARE INTERFACE ROUTINES
0325+  F5B6             ;=============================================================================
0326+  F5B6             ;
0327+  F5B6             ; TAKE ANY ACTIONS REQUIRED TO SELECT DESIRED PHYSICAL UNIT
0328+  F5B6             ;
0329+  F5B6             SD_SELUNIT:
0330+  F5B6 79          	LD	A,C
0331+  F5B7 E6 0F       	AND	0FH		; ISOLATE THE UNIT NIBBLE
0332+  F5B9 FE 01       	CP	SD_UNITCNT	; CHECK VALIDITY (EXCEED UNIT COUNT?)
0333+  F5BB D4 23 FC    	CALL	NC,PANIC	; PANIC ON INVALID VALUE
0334+  F5BE 32 30 FB    	LD	(SD_UNIT),A	; SAVE CURRENT UNIT NUM
0335+  F5C1~            #IF (SDMODE == SDMODE_DSD)
0336+  F5C1~            	; SELECT REQUESTED UNIT
0337+  F5C1~            	OUT	(SD_SELREG),A	; ACTUALLY SELECT THE CARD
0338+  F5C1             #ENDIF
0339+  F5C1 21 2A FB    	LD	HL,SD_STATLST	; POINT TO START OF STATUS LIST
0340+  F5C4 16 00       	LD	D,0		; SETUP DE TO HAVE OFFSET
0341+  F5C6 5F          	LD	E,A		; FOR CURRENT UNIT
0342+  F5C7 19          	ADD	HL,DE		; APPLY THE OFFSET
0343+  F5C8 22 2B FB    	LD	(SD_STATPTR),HL	; SAVE IT
0344+  F5CB 21 2D FB    	LD	HL,SD_TYPELST	; POINT TO START OF CARD TYPE LIST
0345+  F5CE 19          	ADD	HL,DE		; APPLY THE OFFSET
0346+  F5CF 22 2E FB    	LD	(SD_TYPEPTR),HL	; SAVE IT
0347+  F5D2 C9          	RET
0348+  F5D3             ;
0349+  F5D3             ; PERFORM HARDWARE SPECIFIC INITIALIZATION
0350+  F5D3             ;
0351+  F5D3             SD_SETUP:
0352+  F5D3             ;
0353+  F5D3~            #IF ((SDMODE == SDMODE_JUHA) | (SDMODE == SDMODE_N8) | (SDMODE == SDMODE_DSD))
0354+  F5D3~            	LD	A,SD_OPRDEF
0355+  F5D3~            	LD	(SD_OPRVAL),A
0356+  F5D3~            	OUT	(SD_OPRREG),A
0357+  F5D3             #ENDIF
0358+  F5D3             ;
0359+  F5D3~            #IF ((SDMODE == SDMODE_CSIO) | (SDMODE == SDMODE_MK4))
0360+  F5D3~            	; CSIO SETUP
0361+  F5D3~            ;	LD	A,2			; 18MHz/20 <= 400kHz
0362+  F5D3~            	LD	A,6			; ???
0363+  F5D3~            	OUT0	(SD_CNTR),A
0364+  F5D3~            	LD	A,SD_OPRDEF
0365+  F5D3~            	LD	(SD_OPRVAL),A
0366+  F5D3~            	OUT	(SD_OPRREG),A
0367+  F5D3             #ENDIF
0368+  F5D3             ;
0369+  F5D3~            #IF (SDMODE == SDMODE_PPI)
0370+  F5D3~            	LD	A,82H			; PPI PORT A=OUT, B=IN, C=OUT
0371+  F5D3~            	OUT	(PPIX),A
0372+  F5D3~            	;LD	A,30H			; PC4,5 /CS HIGH
0373+  F5D3~            	LD	A,SD_OPRDEF
0374+  F5D3~            	LD	(SD_OPRVAL),A
0375+  F5D3~            	OUT	(SD_OPRREG),A
0376+  F5D3             #ENDIF
0377+  F5D3             ;
0378+  F5D3             #IF (SDMODE == SDMODE_UART)
0379+  F5D3             SD_OPRMSK	.EQU	(SD_CS | SD_CLK | SD_DI)
0380+  F5D3             
0381+  F5D3 DB 94       	IN	A,(SD_OPRREG)		; OPRREG == SIO_MCR
0382+  F5D5             
0383+  F5D5 E6 F2       	AND	~SD_OPRMSK
0384+  F5D7 F6 0C       	OR	SD_OPRDEF
0385+  F5D9             
0386+  F5D9             ;;SD_OPRDEF	.EQU	%00001000	; QUIESCENT STATE???
0387+  F5D9             ;	OR	SD_CS			; OPR:3, DEASSERT = HI = 1
0388+  F5D9             ;	AND	~SD_DI			; OPR:0, ASSERT DIN = LO = 0 (INVERTED)
0389+  F5D9             ;	OR	SD_CLK			; OPR:2, DEASSERT CLK = HI = 1 (INVERTED)
0390+  F5D9             
0391+  F5D9 32 33 FB    	LD	(SD_OPRVAL),A
0392+  F5DC D3 94       	OUT	(SD_OPRREG),A		; OPRREG == SIO_MCR
0393+  F5DE             #ENDIF
0394+  F5DE             ;
0395+  F5DE~            #IF ((SDMODE == SDMODE_DSD) | (SDMODE == SDMODE_MK4))
0396+  F5DE~            	IN	A,(SD_OPRREG)
0397+  F5DE~            	BIT	5,A			; CARD DETECT
0398+  F5DE~            	JP	Z,SD_NOMEDIA		; NO MEDIA DETECTED
0399+  F5DE             #ENDIF
0400+  F5DE             ;
0401+  F5DE AF          	XOR	A
0402+  F5DF C9          	RET
0403+  F5E0             ;
0404+  F5E0             ; SELECT CARD
0405+  F5E0             ;
0406+  F5E0             SD_SELECT:
0407+  F5E0 3A 33 FB    	LD	A,(SD_OPRVAL)
0408+  F5E3             #IF ((SDMODE == SDMODE_PPI) | (SDMODE == SDMODE_UART))
0409+  F5E3 E6 F7       	AND	~SD_CS		; SET SD_CS (CHIP SELECT)
0410+  F5E5~            #ELSE
0411+  F5E5~            	OR	SD_CS		; SET SD_CS (CHIP SELECT)
0412+  F5E5             #ENDIF
0413+  F5E5 32 33 FB    	LD	(SD_OPRVAL),A
0414+  F5E8 D3 94       	OUT	(SD_OPRREG),A
0415+  F5EA C9          	RET
0416+  F5EB             ;
0417+  F5EB             ; DESELECT CARD
0418+  F5EB             ;
0419+  F5EB             SD_DESELECT:
0420+  F5EB 3A 33 FB    	LD	A,(SD_OPRVAL)
0421+  F5EE             #IF ((SDMODE == SDMODE_PPI) | (SDMODE == SDMODE_UART))
0422+  F5EE F6 08       	OR	SD_CS		; RESET SD_CS (CHIP SELECT)
0423+  F5F0~            #ELSE
0424+  F5F0~            	AND	~SD_CS		; RESET SD_CS (CHIP SELECT)
0425+  F5F0             #ENDIF
0426+  F5F0 32 33 FB    	LD	(SD_OPRVAL),A
0427+  F5F3 D3 94       	OUT	(SD_OPRREG),A
0428+  F5F5 C9          	RET
0429+  F5F6             ;
0430+  F5F6             ; CHECK FOR WRITE PROTECT (NZ = WRITE PROTECTED)
0431+  F5F6             ;
0432+  F5F6             SD_CHKWP:
0433+  F5F6~            #IF ((SDMODE == SDMODE_DSD) | (SDMODE == SDMODE_MK4))
0434+  F5F6~            	IN	A,(SD_OPRREG)
0435+  F5F6~            	BIT	4,A
0436+  F5F6             #ELSE
0437+  F5F6 AF          	XOR	A
0438+  F5F7             #ENDIF
0439+  F5F7 C9          	RET
0440+  F5F8             ;
0441+  F5F8             ;
0442+  F5F8             ;
0443+  F5F8~            #IF ((SDMODE == SDMODE_CSIO) | (SDMODE == SDMODE_MK4))
0444+  F5F8~            SD_WAITTX:			; WAIT FOR TX EMPTY	
0445+  F5F8~            	IN0	A,(SD_CNTR)	; GET CSIO STATUS
0446+  F5F8~            	BIT	4,A		; TX EMPTY?
0447+  F5F8~            	JR	NZ,SD_WAITTX
0448+  F5F8~            	RET
0449+  F5F8~            ;
0450+  F5F8~            ;
0451+  F5F8~            ;
0452+  F5F8~            SD_WAITRX:
0453+  F5F8~            	IN0	A,(SD_CNTR)	; WAIT FOR RECEIVER TO FINISH
0454+  F5F8~            	BIT	5,A
0455+  F5F8~            	JR	NZ,SD_WAITRX
0456+  F5F8~            	RET
0457+  F5F8~            ;
0458+  F5F8~            ;
0459+  F5F8~            ;
0460+  F5F8~            MIRROR:				; MSB<-->LSB mirror bits in A, result in C
0461+  F5F8~              #IF (!SDCSIOFAST)		; slow speed, least code space
0462+  F5F8~            	LD      B,8		; bit counter
0463+  F5F8~            MIRROR1:
0464+  F5F8~            	RLA			; rotate bit 7 into carry
0465+  F5F8~            	RR	C		; rotate carry into result
0466+  F5F8~            	DJNZ	MIRROR1		; do all 8 bits
0467+  F5F8~            	RET
0468+  F5F8~              #ELSE				; fastest but uses most code space
0469+  F5F8~            	LD	BC,MIRTAB	; 256 byte mirror table
0470+  F5F8~            	ADD	A,C		; add offset
0471+  F5F8~            	LD	C,A
0472+  F5F8~            	JR	NC,MIRROR2
0473+  F5F8~            	INC	B
0474+  F5F8~            MIRROR2:
0475+  F5F8~            	LD	A,(BC)		; get result
0476+  F5F8~            	LD	C,A		; return result in C
0477+  F5F8~            	RET
0478+  F5F8~              #ENDIF
0479+  F5F8~            ;
0480+  F5F8~            MIRTAB:	.DB 00H, 80H, 40H, 0C0H, 20H, 0A0H, 60H, 0E0H, 10H, 90H, 50H, 0D0H, 30H, 0B0H, 70H, 0F0H
0481+  F5F8~            	.DB 08H, 88H, 48H, 0C8H, 28H, 0A8H, 68H, 0E8H, 18H, 98H, 58H, 0D8H, 38H, 0B8H, 78H, 0F8H
0482+  F5F8~            	.DB 04H, 84H, 44H, 0C4H, 24H, 0A4H, 64H, 0E4H, 14H, 94H, 54H, 0D4H, 34H, 0B4H, 74H, 0F4H
0483+  F5F8~            	.DB 0CH, 8CH, 4CH, 0CCH, 2CH, 0ACH, 6CH, 0ECH, 1CH, 9CH, 5CH, 0DCH, 3CH, 0BCH, 7CH, 0FCH
0484+  F5F8~            	.DB 02H, 82H, 42H, 0C2H, 22H, 0A2H, 62H, 0E2H, 12H, 92H, 52H, 0D2H, 32H, 0B2H, 72H, 0F2H
0485+  F5F8~            	.DB 0AH, 8AH, 4AH, 0CAH, 2AH, 0AAH, 6AH, 0EAH, 1AH, 9AH, 5AH, 0DAH, 3AH, 0BAH, 7AH, 0FAH
0486+  F5F8~            	.DB 06H, 86H, 46H, 0C6H, 26H, 0A6H, 66H, 0E6H, 16H, 96H, 56H, 0D6H, 36H, 0B6H, 76H, 0F6H
0487+  F5F8~            	.DB 0EH, 8EH, 4EH, 0CEH, 2EH, 0AEH, 6EH, 0EEH, 1EH, 9EH, 5EH, 0DEH, 3EH, 0BEH, 7EH, 0FEH
0488+  F5F8~            	.DB 01H, 81H, 41H, 0C1H, 21H, 0A1H, 61H, 0E1H, 11H, 91H, 51H, 0D1H, 31H, 0B1H, 71H, 0F1H
0489+  F5F8~            	.DB 09H, 89H, 49H, 0C9H, 29H, 0A9H, 69H, 0E9H, 19H, 99H, 59H, 0D9H, 39H, 0B9H, 79H, 0F9H
0490+  F5F8~            	.DB 05H, 85H, 45H, 0C5H, 25H, 0A5H, 65H, 0E5H, 15H, 95H, 55H, 0D5H, 35H, 0B5H, 75H, 0F5H
0491+  F5F8~            	.DB 0DH, 8DH, 4DH, 0CDH, 2DH, 0ADH, 6DH, 0EDH, 1DH, 9DH, 5DH, 0DDH, 3DH, 0BDH, 7DH, 0FDH
0492+  F5F8~            	.DB 03H, 83H, 43H, 0C3H, 23H, 0A3H, 63H, 0E3H, 13H, 93H, 53H, 0D3H, 33H, 0B3H, 73H, 0F3H
0493+  F5F8~            	.DB 0BH, 8BH, 4BH, 0CBH, 2BH, 0ABH, 6BH, 0EBH, 1BH, 9BH, 5BH, 0DBH, 3BH, 0BBH, 7BH, 0FBH
0494+  F5F8~            	.DB 07H, 87H, 47H, 0C7H, 27H, 0A7H, 67H, 0E7H, 17H, 97H, 57H, 0D7H, 37H, 0B7H, 77H, 0F7H
0495+  F5F8~            	.DB 0FH, 8FH, 4FH, 0CFH, 2FH, 0AFH, 6FH, 0EFH, 1FH, 9FH, 5FH, 0DFH, 3FH, 0BFH, 7FH, 0FFH
0496+  F5F8             #ENDIF
0497+  F5F8             ;
0498+  F5F8             ; SEND ONE BYTE
0499+  F5F8             ;
0500+  F5F8             SD_PUT:
0501+  F5F8~            #IF ((SDMODE == SDMODE_CSIO) | (SDMODE == SDMODE_MK4))
0502+  F5F8~            	CALL	MIRROR		; MSB<-->LSB mirror bits, result in C
0503+  F5F8~            	CALL	SD_WAITTX	; MAKE SURE WE ARE DONE SENDING
0504+  F5F8~            	OUT0	(SD_TRDR),C	; PUT BYTE IN BUFFER
0505+  F5F8~            	IN0	A,(SD_CNTR)
0506+  F5F8~            	SET	4,A		; SET TRANSMIT ENABLE
0507+  F5F8~            	OUT0	(SD_CNTR),A
0508+  F5F8             #ELSE
0509+  F5F8             #IF (SDMODE == SDMODE_UART)
0510+  F5F8 EE FF       	XOR	$FF		; DI IS INVERTED ON UART
0511+  F5FA             #ENDIF
0512+  F5FA 4F          	LD	C,A		; C=BYTE TO SEND
0513+  F5FB 06 08       	LD	B,8		; SEND 8 BITS (LOOP 8 TIMES)
0514+  F5FD 3A 33 FB    	LD	A,(SD_OPRVAL)	; LOAD CURRENT OPR VALUE
0515+  F600             SD_PUT1:
0516+  F600 1F          	RRA			; PREPARE TO GET DATA BIT FROM CF
0517+  F601 CB 11       	RL	C		; ROTATE NEXT BIT FROM C INTO CF
0518+  F603 17          	RLA			; ROTATE CF INTO A:0, SD_DO is OPR:0
0519+  F604 D3 94       	OUT	(SD_OPRREG),A	; ASSERT DATA BIT
0520+  F606 EE 04       	XOR	SD_CLK		; TOGGLE CLOCK
0521+  F608 D3 94       	OUT	(SD_OPRREG),A	; UPDATE CLOCK AND ASSERT DATA BIT
0522+  F60A EE 04       	XOR	SD_CLK		; TOGGLE CLOCK
0523+  F60C D3 94       	OUT	(SD_OPRREG),A	; UPDATE CLOCK
0524+  F60E 10 F0       	DJNZ	SD_PUT1		; REPEAT FOR ALL 8 BITS
0525+  F610 3A 33 FB    	LD	A,(SD_OPRVAL)	; LOAD CURRENT OPR VALUE
0526+  F613 D3 94       	OUT	(SD_OPRREG),A	; LEAVE WITH CLOCK LOW
0527+  F615             #ENDIF
0528+  F615 C9          	RET			; DONE
0529+  F616             ;
0530+  F616             ; RECEIVE ONE BYTE
0531+  F616             ;
0532+  F616             SD_GET:
0533+  F616~            #IF ((SDMODE == SDMODE_CSIO) | (SDMODE == SDMODE_MK4))
0534+  F616~            	CALL	SD_WAITTX	; MAKE SURE WE ARE DONE SENDING
0535+  F616~            	IN0	A,(CPU_CNTR)	; GET CSIO STATUS
0536+  F616~            	SET	5,A		; START RECEIVER
0537+  F616~            	OUT0	(CPU_CNTR),A
0538+  F616~            	CALL	SD_WAITRX
0539+  F616~            	IN0	A,(CPU_TRDR)	; GET RECEIVED BYTE
0540+  F616~            	CALL	MIRROR		; MSB<-->LSB MIRROR BITS
0541+  F616~            	LD	A,C		; KEEP RESULT
0542+  F616             #ELSE
0543+  F616 06 08       	LD	B,8		; RECEIVE 8 BITS (LOOP 8 TIMES)
0544+  F618 3A 33 FB    	LD	A,(SD_OPRVAL)	; LOAD CURRENT OPR VALUE
0545+  F61B             SD_GET1:
0546+  F61B EE 04       	XOR	SD_CLK		; TOGGLE CLOCK
0547+  F61D D3 94       	OUT	(SD_OPRREG),A	; UPDATE CLOCK
0548+  F61F DB 96       	IN	A,(SD_INPREG)	; READ THE DATA WHILE CLOCK IS ACTIVE
0549+  F621~              #IF ((SDMODE == SDMODE_JUHA) | (SDMODE == SDMODE_PPI))
0550+  F621~            	RLA			; ROTATE INP:7 INTO CF
0551+  F621               #ENDIF
0552+  F621~              #IF (SDMODE == SDMODE_N8)
0553+  F621~            	RLA			; ROTATE INP:6 INTO CF
0554+  F621~            	RLA			; "
0555+  F621               #ENDIF
0556+  F621               #IF (SDMODE == SDMODE_UART)
0557+  F621 17          	RLA			; ROTATE INP:5 INTO CF
0558+  F622 17          	RLA			; "
0559+  F623 17          	RLA			; "
0560+  F624               #ENDIF
0561+  F624~              #IF (SDMODE == SDMODE_DSD)
0562+  F624~            	RRA			; ROTATE INP:0 INTO CF
0563+  F624               #ENDIF
0564+  F624 CB 11       	RL	C		; ROTATE CF INTO C:0
0565+  F626 3A 33 FB    	LD	A,(SD_OPRVAL)	; BACK TO INITIAL VALUES (TOGGLE CLOCK)
0566+  F629 D3 94       	OUT	(SD_OPRREG),A	; DO IT
0567+  F62B 10 EE       	DJNZ	SD_GET1		; REPEAT FOR ALL 8 BITS
0568+  F62D 79          	LD	A,C		; GET BYTE RECEIVED INTO A
0569+  F62E             #IF (SDMODE == SDMODE_UART)
0570+  F62E EE FF       	XOR	$FF		; DO IS INVERTED ON UART
0571+  F630             #ENDIF
0572+  F630             #ENDIF
0573+  F630 C9          	RET
0574+  F631             ;
0575+  F631             ;==================================================================================================
0576+  F631             ;   SD DISK DRIVER PROTOCOL IMPLEMENTATION
0577+  F631             ;==================================================================================================
0578+  F631             ;
0579+  F631             ; SELECT CARD AND WAIT FOR IT TO BE READY ($FF)
0580+  F631             ;
0581+  F631             SD_WAITRDY:
0582+  F631 CD E0 F5    	CALL	SD_SELECT	; SELECT CARD
0583+  F634 11 00 00    	LD	DE,0		; LOOP MAX (TIMEOUT)
0584+  F637             SD_WAITRDY1:
0585+  F637 CD 16 F6    	CALL	SD_GET
0586+  F63A 3C          	INC	A		; $FF -> $00
0587+  F63B C8          	RET	Z		; IF READY, RETURN
0588+  F63C 1B          	DEC	DE
0589+  F63D 7A          	LD	A,D
0590+  F63E B3          	OR	E
0591+  F63F 20 F6       	JR	NZ,SD_WAITRDY1	; KEEP TRYING UNTIL TIMEOUT
0592+  F641 AF          	XOR	A		; ZERO ACCUM
0593+  F642 3D          	DEC	A		; ACCUM := $FF TO SIGNAL ERROR
0594+  F643 C9          	RET			; TIMEOUT
0595+  F644             ;
0596+  F644             ; COMPLETE A TRANSACTION - PRESERVE AF
0597+  F644             ;
0598+  F644             SD_DONE:
0599+  F644 F5          	PUSH	AF
0600+  F645 CD EB F5    	CALL	SD_DESELECT
0601+  F648 3E FF       	LD	A,$FF
0602+  F64A CD F8 F5    	CALL	SD_PUT
0603+  F64D F1          	POP	AF
0604+  F64E C9          	RET
0605+  F64F             ;
0606+  F64F             ; SD_GETDATA
0607+  F64F             ;
0608+  F64F             SD_GETDATA:
0609+  F64F E5          	PUSH	HL		; SAVE DESTINATION ADDRESS
0610+  F650 C5          	PUSH	BC		; SAVE LENGTH TO RECEIVE
0611+  F651 11 FF 7F    	LD	DE,$7FFF	; LOOP MAX (TIMEOUT)
0612+  F654             SD_GETDATA1:
0613+  F654 CD 16 F6    	CALL	SD_GET
0614+  F657 FE FF       	CP	$FF		; WANT BYTE != $FF
0615+  F659 20 05       	JR	NZ,SD_GETDATA2	; NOT $FF, MOVE ON
0616+  F65B 1B          	DEC    DE
0617+  F65C CB 7A       	BIT	7,D
0618+  F65E 28 F4       	JR	Z,SD_GETDATA1	; KEEP TRYING UNTIL TIMEOUT
0619+  F660             SD_GETDATA2:
0620+  F660 32 32 FB    	LD	(SD_TOK),A
0621+  F663 D1          	POP	DE		; RESTORE LENGTH TO RECEIVE
0622+  F664 E1          	POP	HL		; RECOVER DEST ADDRESS
0623+  F665 FE FE       	CP	$FE		; PACKET START?
0624+  F667 20 11       	JR	NZ,SD_GETDATA4	; NOPE, ABORT, A HAS ERROR CODE
0625+  F669             SD_GETDATA3:
0626+  F669 CD 16 F6    	CALL	SD_GET		; GET NEXT BYTE
0627+  F66C 77          	LD	(HL),A		; SAVE IT
0628+  F66D 23          	INC	HL
0629+  F66E 1B          	DEC	DE
0630+  F66F 7A          	LD	A,D
0631+  F670 B3          	OR	E
0632+  F671 20 F6       	JR	NZ,SD_GETDATA3	; LOOP FOR ALL BYTES
0633+  F673 CD 16 F6    	CALL	SD_GET		; DISCARD CRC BYTE 1
0634+  F676 CD 16 F6    	CALL	SD_GET		; DISCARD CRC BYTE 2
0635+  F679 AF          	XOR	A		; RESULT IS ZERO
0636+  F67A             SD_GETDATA4:
0637+  F67A C9          	RET
0638+  F67B             ;
0639+  F67B             ; SD_PUTDATA
0640+  F67B             ;
0641+  F67B             SD_PUTDATA:
0642+  F67B E5          	PUSH	HL		; SAVE SOURCE ADDRESS
0643+  F67C C5          	PUSH	BC		; SAVE LENGTH TO SEND
0644+  F67D             	
0645+  F67D 3E FE       	LD	A,$FE		; PACKET START
0646+  F67F CD F8 F5    	CALL	SD_PUT		; SEND IT
0647+  F682             
0648+  F682 D1          	POP	DE		; RECOVER LENGTH TO SEND
0649+  F683 E1          	POP	HL		; RECOVER SOURCE ADDRESS
0650+  F684             SD_PUTDATA1:
0651+  F684 7E          	LD	A,(HL)		; GET NEXT BYTE TO SEND
0652+  F685 CD F8 F5    	CALL	SD_PUT		; SEND IF
0653+  F688 23          	INC	HL
0654+  F689 1B          	DEC	DE
0655+  F68A 7A          	LD	A,D
0656+  F68B B3          	OR	E
0657+  F68C 20 F6       	JR	NZ,SD_PUTDATA1	; LOOP FOR ALL BYTES
0658+  F68E 3E FF       	LD	A,$FF		; DUMMY CRC BYTE
0659+  F690 CD F8 F5    	CALL	SD_PUT
0660+  F693 3E FF       	LD	A,$FF		; DUMMY CRC BYTE
0661+  F695 CD F8 F5    	CALL	SD_PUT
0662+  F698 11 FF 7F    	LD	DE,$7FFF	; LOOP MAX (TIMEOUT)
0663+  F69B             SD_PUTDATA2:
0664+  F69B CD 16 F6    	CALL	SD_GET
0665+  F69E FE FF       	CP	$FF		; WANT BYTE != $FF
0666+  F6A0 20 05       	JR	NZ,SD_PUTDATA3	; NOT $FF, MOVE ON
0667+  F6A2 1B          	DEC    DE
0668+  F6A3 CB 7A       	BIT	7,D
0669+  F6A5 28 F4       	JR	Z,SD_PUTDATA2	; KEEP TRYING UNTIL TIMEOUT
0670+  F6A7             SD_PUTDATA3:
0671+  F6A7 E6 1F       	AND	$1F
0672+  F6A9 32 32 FB    	LD	(SD_TOK),A
0673+  F6AC FE 05       	CP	$05
0674+  F6AE C0          	RET	NZ
0675+  F6AF AF          	XOR	A
0676+  F6B0 C9          	RET
0677+  F6B1             ;
0678+  F6B1             ; SETUP COMMAND BUFFER
0679+  F6B1             ;
0680+  F6B1             SD_SETCMD0:	; NO PARMS
0681+  F6B1 21 45 FB    	LD	HL,SD_CMDBUF
0682+  F6B4 77          	LD	(HL),A
0683+  F6B5 23          	INC	HL
0684+  F6B6 AF          	XOR	A
0685+  F6B7 77          	LD	(HL),A
0686+  F6B8 23          	INC	HL
0687+  F6B9 77          	LD	(HL),A
0688+  F6BA 23          	INC	HL
0689+  F6BB 77          	LD	(HL),A
0690+  F6BC 23          	INC	HL
0691+  F6BD 77          	LD	(HL),A
0692+  F6BE 23          	INC	HL
0693+  F6BF 3E FF       	LD	A,$FF
0694+  F6C1 77          	LD	(HL),A
0695+  F6C2 C9          	RET
0696+  F6C3             ;
0697+  F6C3             SD_SETCMDP:	; W/ PARMS IN BC & DE
0698+  F6C3 CD B1 F6    	CALL	SD_SETCMD0
0699+  F6C6 21 46 FB    	LD	HL,SD_CMDP0
0700+  F6C9 70          	LD	(HL),B
0701+  F6CA 23          	INC	HL
0702+  F6CB 71          	LD	(HL),C
0703+  F6CC 23          	INC	HL
0704+  F6CD 72          	LD	(HL),D
0705+  F6CE 23          	INC	HL
0706+  F6CF 73          	LD	(HL),E
0707+  F6D0 C9          	RET	
0708+  F6D1             ;
0709+  F6D1             ; EXECUTE A SD CARD COMMAND
0710+  F6D1             ;
0711+  F6D1             SD_EXEC:
0712+  F6D1 CD 31 F6    	CALL	SD_WAITRDY
0713+  F6D4 C2 65 F9    	JP	NZ,SD_ERRRDYTO	; RETURN VIA READY TIMEOUT HANDLER
0714+  F6D7 AF          	XOR	A
0715+  F6D8 32 31 FB    	LD	(SD_RC),A
0716+  F6DB 32 32 FB    	LD	(SD_TOK),A
0717+  F6DE 21 45 FB    	LD	HL,SD_CMDBUF
0718+  F6E1 1E 06       	LD	E,6		; COMMANDS ARE 6 BYTES
0719+  F6E3             SD_EXEC1:
0720+  F6E3 7E          	LD	A,(HL)
0721+  F6E4 CD F8 F5    	CALL	SD_PUT
0722+  F6E7 23          	INC	HL
0723+  F6E8 1D          	DEC	E
0724+  F6E9 20 F8       	JR	NZ,SD_EXEC1
0725+  F6EB 11 00 01    	LD	DE,$100		; LOOP MAX (TIMEOUT)
0726+  F6EE             	;LD	DE,$8000	; *DEBUG*
0727+  F6EE             SD_EXEC2:
0728+  F6EE CD 16 F6    	CALL	SD_GET
0729+  F6F1             	;CALL	PRTHEXBYTE	; *DEBUG*
0730+  F6F1 B7          	OR	A		; SET FLAGS
0731+  F6F2 F2 FD F6    	JP	P,SD_EXEC3	; IF HIGH BIT IS 0, WE HAVE RESULT
0732+  F6F5 1B          	DEC	DE
0733+  F6F6 CB 7A       	BIT	7,D
0734+  F6F8 28 F4       	JR	Z,SD_EXEC2
0735+  F6FA             	;LD	(SD_RC),A	; *DEBUG*
0736+  F6FA             	;CALL	SD_PRTTRN	; *DEBUG*
0737+  F6FA C3 6D F9    	JP	SD_ERRCMDTO
0738+  F6FD             SD_EXEC3:
0739+  F6FD 32 31 FB    	LD	(SD_RC),A
0740+  F700~            #IF (SDTRACE >= 2)
0741+  F700~            	CALL	SD_PRTTRN
0742+  F700             #ENDIF
0743+  F700~            #IF (DSKYENABLE)
0744+  F700~            	CALL	SD_DSKY
0745+  F700             #ENDIF
0746+  F700 B7          	OR	A
0747+  F701 C9          	RET
0748+  F702             ;	
0749+  F702             SD_EXECCMD0:	; EXEC COMMAND, NO PARMS
0750+  F702 CD B1 F6    	CALL	SD_SETCMD0
0751+  F705 18 CA       	JR	SD_EXEC
0752+  F707             ;
0753+  F707             SD_EXECCMDP:	; EXEC CMD W/ PARMS IN BC/DE
0754+  F707 CD C3 F6    	CALL	SD_SETCMDP
0755+  F70A 18 C5       	JR	SD_EXEC
0756+  F70C             ;
0757+  F70C             ; PUT CARD IN IDLE STATE
0758+  F70C             ;
0759+  F70C             SD_GOIDLE:
0760+  F70C             	;CALL	SD_DONE			; SEEMS TO HELP SOME CARDS...
0761+  F70C             
0762+  F70C             	; SMALL DELAY HERE HELPS SOME CARDS
0763+  F70C 11 C8 00    	LD	DE,200			; 5 MILISECONDS
0764+  F70F CD E1 FC    	CALL	VDELAY
0765+  F712             
0766+  F712             	; PUT CARD IN IDLE STATE
0767+  F712 3E 40       	LD	A,SD_CMD0		; CMD0 = ENTER IDLE STATE
0768+  F714 CD B1 F6    	CALL	SD_SETCMD0
0769+  F717 3E 95       	LD	A,$95
0770+  F719 32 4A FB    	LD	(SD_CMDBUF+5),A		; SET CRC=$95
0771+  F71C CD D1 F6    	CALL	SD_EXEC			; EXEC CMD
0772+  F71F CD 44 F6    	CALL	SD_DONE			; SIGNAL COMMAND COMPLETE
0773+  F722 F2 2C F7    	JP	P,SD_GOIDLE1		; VALID RESULT, CHECK IT
0774+  F725 CD D1 F6    	CALL	SD_EXEC			; 2ND TRY
0775+  F728 CD 44 F6    	CALL	SD_DONE			; SIGNAL COMMAND COMPLETE
0776+  F72B F8          	RET	M			; COMMAND FAILED
0777+  F72C             ;
0778+  F72C             SD_GOIDLE1:	; COMMAND OK, CHECK FOR EXPECTED RESULT
0779+  F72C 3D          	DEC	A			; MAP EXPECTED $01 -> $00
0780+  F72D C8          	RET	Z			; IF $00, ALL GOOD, RETURN
0781+  F72E C3 71 F9    	JP	SD_ERRCMD		; OTHERWISE, HANDLE COMMAND ERROR
0782+  F731             ;
0783+  F731             ; INIT CARD
0784+  F731             ;
0785+  F731             SD_INITCARD:
0786+  F731 CD D3 F5    	CALL	SD_SETUP		; DO HARDWARE SETUP/INIT
0787+  F734 C0          	RET	NZ
0788+  F735             ;	
0789+  F735             	; WAKE UP THE CARD, KEEP DIN HI (ASSERTED) AND /CS HI (DEASSERTED)
0790+  F735 06 10       	LD	B,$10	; MIN 74 CLOCKS REQUIRED, WE USE 128 ($10 * 8)
0791+  F737             SD_INITCARD000:
0792+  F737 3E FF       	LD	A,$FF
0793+  F739 C5          	PUSH	BC
0794+  F73A CD F8 F5    	CALL	SD_PUT
0795+  F73D C1          	POP	BC
0796+  F73E 10 F7       	DJNZ	SD_INITCARD000
0797+  F740             
0798+  F740             	;CALL	SD_SELECT
0799+  F740             
0800+  F740             	; PUT CARD IN IDLE STATE
0801+  F740 CD 0C F7    	CALL	SD_GOIDLE
0802+  F743 C0          	RET	NZ			; FAILED
0803+  F744             
0804+  F744             SD_INITCARD00:
0805+  F744 3E 02       	LD	A,SD_TYPESDSC		; ASSUME SDSC CARD TYPE
0806+  F746 2A 2E FB    	LD	HL,(SD_TYPEPTR)		; LOAD THE CARD TYPE ADDRESS
0807+  F749 77          	LD	(HL),A			; SAVE IT
0808+  F74A             
0809+  F74A             	; CMD8 IS REQUIRED FOR V2 CARDS.  FAILURE HERE IS OK AND
0810+  F74A             	; JUST MEANS THAT IT IS A V1.X CARD
0811+  F74A 3E 48       	LD	A,SD_CMD8
0812+  F74C 01 00 00    	LD	BC,0
0813+  F74F 16 01       	LD	D,1			; VHS=1, 2.7-3.6V
0814+  F751 1E AA       	LD	E,$AA			; CHECK PATTERN
0815+  F753 CD C3 F6    	CALL	SD_SETCMDP
0816+  F756 3E 87       	LD	A,$87
0817+  F758 32 4A FB    	LD	(SD_CMDBUF+5),A		; SET CRC=$87
0818+  F75B CD D1 F6    	CALL	SD_EXEC			; EXEC CMD
0819+  F75E FC 44 F6    	CALL	M,SD_DONE		; CLOSE COMMAND IF ERROR
0820+  F761 F8          	RET	M			; ABORT DUE TO PROCESSING ERROR
0821+  F762 E6 FE       	AND	~$01			; IGNORE BIT 0 (IDLE)
0822+  F764 20 0C       	JR	NZ,SD_INITCARD0		; CMD RESULT ERR, SKIP AHEAD
0823+  F766             	
0824+  F766             	; CMD8 WORKED, NEED TO CONSUME CMD8 RESPONSE BYTES (4)
0825+  F766 CD 16 F6    	CALL	SD_GET
0826+  F769 CD 16 F6    	CALL	SD_GET
0827+  F76C CD 16 F6    	CALL	SD_GET
0828+  F76F CD 16 F6    	CALL	SD_GET
0829+  F772             	
0830+  F772             SD_INITCARD0:
0831+  F772 CD 44 F6    	CALL	SD_DONE
0832+  F775             
0833+  F775 3E 00       	LD	A,0
0834+  F777 32 34 FB    	LD	(SD_LCNT),A
0835+  F77A             SD_INITCARD1:
0836+  F77A             	; CALL SD_APP_OP_COND UNTIL CARD IS READY (NOT IDLE)
0837+  F77A 11 C8 00    	LD	DE,200		; 5 MILLISECONDS
0838+  F77D CD E1 FC    	CALL	VDELAY
0839+  F780 3E 77       	LD	A,SD_CMD55	; APP CMD IS NEXT
0840+  F782 CD 02 F7    	CALL	SD_EXECCMD0
0841+  F785 CD 44 F6    	CALL	SD_DONE
0842+  F788 F8          	RET	M		; ABORT ON PROCESSING ERROR
0843+  F789 E6 FE       	AND	~$01		; ONLY 0 (OK) OR 1 (IDLE) ARE OK
0844+  F78B C2 71 F9    	JP	NZ,SD_ERRCMD
0845+  F78E 3E 69       	LD	A,SD_ACMD41	; SD_APP_OP_COND
0846+  F790 01 00 40    	LD	BC,$4000	; INDICATE WE SUPPORT HC
0847+  F793 11 00 00    	LD	DE,$0000
0848+  F796 CD 07 F7    	CALL	SD_EXECCMDP
0849+  F799 CD 44 F6    	CALL	SD_DONE
0850+  F79C F8          	RET	M		; ABORT ON PROCESSING ERROR
0851+  F79D FE 00       	CP	$00		; INIT DONE?
0852+  F79F 28 11       	JR	Z,SD_INITCARD2	; YUP, MOVE ON
0853+  F7A1 FE 01       	CP	$01		; IDLE?
0854+  F7A3 C2 71 F9    	JP	NZ,SD_ERRCMD	; NOPE, MUST BE CMD ERROR, ABORT
0855+  F7A6 21 34 FB    	LD	HL,SD_LCNT	; POINT TO LOOP COUNTER
0856+  F7A9 35          	DEC	(HL)		; DECREMENT LOOP COUNTER
0857+  F7AA 20 CE       	JR	NZ,SD_INITCARD1	; LOOP UNTIL COUNTER EXHAUSTED
0858+  F7AC 3E FF       	LD	A,$FF		; SIGNAL TIMEOUT
0859+  F7AE B7          	OR	A
0860+  F7AF C3 69 F9    	JP	SD_ERRINITTO
0861+  F7B2             	
0862+  F7B2             SD_INITCARD2:
0863+  F7B2             	; CMD58 RETURNS THE 32 BIT OCR REGISTER, WE WANT TO CHECK
0864+  F7B2             	; BIT 30, IF SET THIS IS SDHC/XC CARD
0865+  F7B2 3E 7A       	LD	A,SD_CMD58
0866+  F7B4 CD 02 F7    	CALL	SD_EXECCMD0
0867+  F7B7 C4 44 F6    	CALL	NZ,SD_DONE
0868+  F7BA F8          	RET	M		; ABORT ON PROCESSING ERROR
0869+  F7BB C2 71 F9    	JP	NZ,SD_ERRCMD
0870+  F7BE             	
0871+  F7BE             	; CMD58 WORKED, GET OCR DATA AND SET CARD TYPE
0872+  F7BE CD 16 F6    	CALL	SD_GET		; BITS 31-24
0873+  F7C1 E6 40       	AND	$40		; ISOLATE BIT 30 (CCS)
0874+  F7C3 28 06       	JR	Z,SD_INITCARD21	; NOT HC/XC, BYPASS
0875+  F7C5 2A 2E FB    	LD	HL,(SD_TYPEPTR)	; LOAD THE CARD TYPE ADDRESS
0876+  F7C8 3E 03       	LD	A,SD_TYPESDHC	; CARD TYPE = SDHC
0877+  F7CA 77          	LD	(HL),A		; SAVE IT
0878+  F7CB             SD_INITCARD21:
0879+  F7CB CD 16 F6    	CALL	SD_GET		; BITS 23-16, DISCARD
0880+  F7CE CD 16 F6    	CALL	SD_GET		; BITS 15-8, DISCARD
0881+  F7D1 CD 16 F6    	CALL	SD_GET		; BITS 7-0, DISCARD
0882+  F7D4 CD 44 F6    	CALL	SD_DONE
0883+  F7D7             	
0884+  F7D7             	; SET OUR DESIRED BLOCK LENGTH (512 BYTES)
0885+  F7D7 3E 50       	LD	A,SD_CMD16	; SET_BLOCK_LEN
0886+  F7D9 01 00 00    	LD	BC,0
0887+  F7DC 11 00 02    	LD	DE,512
0888+  F7DF CD 07 F7    	CALL	SD_EXECCMDP
0889+  F7E2 CD 44 F6    	CALL	SD_DONE
0890+  F7E5 F8          	RET	M		; ABORT ON PROCESSING ERROR
0891+  F7E6 C2 71 F9    	JP	NZ,SD_ERRCMD
0892+  F7E9             	
0893+  F7E9~            #IF (SDTRACE >= 2)
0894+  F7E9~            	CALL	NEWLINE
0895+  F7E9~            	LD	DE,SDSTR_SDTYPE
0896+  F7E9~            	CALL	WRITESTR
0897+  F7E9~            	LD	HL,(SD_TYPEPTR)
0898+  F7E9~            	LD	A,(HL)
0899+  F7E9~            	CALL	PRTHEXBYTE
0900+  F7E9             #ENDIF
0901+  F7E9             
0902+  F7E9~            #IF ((SDMODE == SDMODE_CSIO) | (SDMODE == SDMODE_MK4))
0903+  F7E9~            	CALL	SD_WAITTX	; MAKE SURE WE ARE DONE SENDING
0904+  F7E9~            	XOR	A		; NOW SET CSIO PORT TO FULL SPEED
0905+  F7E9~            	OUT	(CPU_CNTR),A
0906+  F7E9             #ENDIF
0907+  F7E9             
0908+  F7E9 AF          	XOR	A		; A = 0 (STATUS = OK)
0909+  F7EA 2A 2B FB    	LD	HL,(SD_STATPTR)	; LOAD STATUS ADDRESS
0910+  F7ED 77          	LD	(HL),A		; SAVE IT
0911+  F7EE C9          	RET			; RETURN WITH A=0, AND Z SET
0912+  F7EF             	
0913+  F7EF             ;
0914+  F7EF             ; GET AND PRINT CSD, CID
0915+  F7EF             ;
0916+  F7EF             SD_PRTINFO:
0917+  F7EF CD 91 F9    	CALL	SD_PRTPREFIX
0918+  F7F2             	
0919+  F7F2             	; PRINT CARD TYPE
0920+  F7F2 CD AC FB    	PRTS(" TYPE=$")
0920+  F7F5 20 54 59 50 
0920+  F7F9 45 3D 24 
0921+  F7FC 2A 2E FB    	LD	HL,(SD_TYPEPTR)
0922+  F7FF 7E          	LD	A,(HL)
0923+  F800 11 19 FB    	LD	DE,SDSTR_TYPEMMC
0924+  F803 FE 01       	CP	SD_TYPEMMC
0925+  F805 28 11       	JR	Z,SD_PRTINFO1
0926+  F807 11 1D FB    	LD	DE,SDSTR_TYPESDSC
0927+  F80A FE 02       	CP	SD_TYPESDSC
0928+  F80C 28 0A       	JR	Z,SD_PRTINFO1
0929+  F80E 11 22 FB    	LD	DE,SDSTR_TYPESDHC
0930+  F811 FE 03       	CP	SD_TYPESDHC
0931+  F813 28 03       	JR	Z,SD_PRTINFO1
0932+  F815 11 15 FB    	LD	DE,SDSTR_TYPEUNK
0933+  F818             SD_PRTINFO1:
0934+  F818 CD 13 FC    	CALL	WRITESTR
0935+  F81B             
0936+  F81B 3E 4A       	LD	A,SD_CMD10	; SEND_CID
0937+  F81D CD 02 F7    	CALL	SD_EXECCMD0
0938+  F820 C4 44 F6    	CALL	NZ,SD_DONE
0939+  F823 C2 71 F9    	JP	NZ,SD_ERRCMD	; ABORT IF PROBLEM
0940+  F826 01 10 00    	LD	BC,16		; 16 BYTES OF CID
0941+  F829 21 35 FB    	LD	HL,SD_BUF
0942+  F82C CD 4F F6    	CALL	SD_GETDATA
0943+  F82F CD 44 F6    	CALL	SD_DONE
0944+  F832             
0945+  F832~            #IF (SDTRACE >= 2)
0946+  F832~            	CALL	SD_PRTPREFIX
0947+  F832~            	LD	DE,SDSTR_CID
0948+  F832~            	CALL	WRITESTR
0949+  F832~            	LD	DE,SD_BUF
0950+  F832~            	LD	A,16
0951+  F832~            	CALL	PRTHEXBUF
0952+  F832             #ENDIF
0953+  F832             
0954+  F832             	; PRINT PRODUCT NAME
0955+  F832 CD AC FB    	PRTS(" NAME=$")
0955+  F835 20 4E 41 4D 
0955+  F839 45 3D 24 
0956+  F83C 06 05       	LD	B,5
0957+  F83E 21 38 FB    	LD	HL,SD_BUF + 3
0958+  F841             SD_PRTINFO2:
0959+  F841 7E          	LD	A,(HL)
0960+  F842 CD 72 FC    	CALL	COUT
0961+  F845 23          	INC	HL
0962+  F846 10 F9       	DJNZ	SD_PRTINFO2
0963+  F848             
0964+  F848 3E 49       	LD	A,SD_CMD9	; SEND_CSD
0965+  F84A CD 02 F7    	CALL	SD_EXECCMD0
0966+  F84D C4 44 F6    	CALL	NZ,SD_DONE
0967+  F850 C2 71 F9    	JP	NZ,SD_ERRCMD	; ABORT IF PROBLEM
0968+  F853 01 10 00    	LD	BC,16		; 16 BYTES OF CSD
0969+  F856 21 35 FB    	LD	HL,SD_BUF
0970+  F859 CD 4F F6    	CALL	SD_GETDATA
0971+  F85C CD 44 F6    	CALL	SD_DONE
0972+  F85F             
0973+  F85F~            #IF (SDTRACE >= 2)
0974+  F85F~            	CALL	SD_PRTPREFIX
0975+  F85F~            	LD	DE,SDSTR_CSD
0976+  F85F~            	CALL	WRITESTR
0977+  F85F~            	LD	DE,SD_BUF
0978+  F85F~            	LD	A,16
0979+  F85F~            	CALL	PRTHEXBUF
0980+  F85F             #ENDIF
0981+  F85F             
0982+  F85F             	; PRINT SIZE
0983+  F85F CD AC FB    	PRTS(" SIZE=$")			; PREFIX
0983+  F862 20 53 49 5A 
0983+  F866 45 3D 24 
0984+  F869 DD E5       	PUSH	IX			; SAVE IX
0985+  F86B DD 21 35 FB 	LD	IX,SD_BUF		; POINT IX TO BUFFER
0986+  F86F             ;
0987+  F86F 2A 2E FB    	LD	HL,(SD_TYPEPTR)		; POINT TO CARD TYPE
0988+  F872 7E          	LD	A,(HL)			; GET CARD TYPE
0989+  F873 FE 02       	CP	SD_TYPESDSC		; CSD V1?
0990+  F875 28 06       	JR	Z,SD_PRTINFO3		; HANDLE V1
0991+  F877 FE 03       	CP	SD_TYPESDHC		; CSD V2?
0992+  F879 28 3B       	JR	Z,SD_PRTINFO4		; HANDLE V2
0993+  F87B 18 51       	JR	SD_PRTINFO6		; UNK, CAN'T HANDLE
0994+  F87D             
0995+  F87D             SD_PRTINFO3:	; PRINT SIZE FOR V1 CARD
0996+  F87D DD 7E 06    	LD	A,(IX+6)		; GET C_SIZE MSB
0997+  F880 E6 03       	AND	%00000011		; MASK OFF TOP 6 BITS (NOT PART OF C_SIZE)
0998+  F882 4F          	LD	C,A			; MSB -> C
0999+  F883 DD 56 07    	LD	D,(IX+7)		; D
1000+  F886 DD 5E 08    	LD	E,(IX+8)		; LSB -> E
1001+  F889 06 06       	LD	B,6			; RIGHT SHIFT WHOLE THING BY 6 BITS
1002+  F88B             SD_PRTINFO3A:
1003+  F88B CB 29       	SRA	C			; SHIFT MSB
1004+  F88D CB 1A       	RR	D			; SHIFT NEXT BYTE
1005+  F88F CB 1B       	RR	E			; SHIFT LSB
1006+  F891 10 F8       	DJNZ	SD_PRTINFO3A		; LOOP TILL DONE
1007+  F893 D5          	PUSH	DE			; DE = C_SIZE
1008+  F894 DD 7E 09    	LD	A,(IX+9)		; GET C_SIZE_MULT MSB
1009+  F897 DD 46 0A    	LD	B,(IX+10)		; GET C_SIZE_MULT LSB
1010+  F89A CB 20       	SLA	B			; SHIFT LEFT MSB
1011+  F89C 17          	RLA				; SHIFT LEFT LSB
1012+  F89D E6 07       	AND	%00000111		; ISOLATE RELEVANT BITS
1013+  F89F 4F          	LD	C,A			; C := C_SIZE_MULT
1014+  F8A0 DD 7E 05    	LD	A,(IX+5)		; GET READ_BL_LEN
1015+  F8A3 E6 0F       	AND	%00001111		; ISLOATE RELEVANT BITS
1016+  F8A5 47          	LD	B,A			; B := READ_BL_LEN
1017+  F8A6 3E 12       	LD	A,18			; ASSUME RIGHT SHIFT OF 18
1018+  F8A8 90          	SUB	B			; REDUCE BY READ_BL_LEN BITS
1019+  F8A9 91          	SUB	C			; REDUCE BY C_SIZE_MULT BITS
1020+  F8AA 47          	LD	B,A			; PUT IN LOOP COUNTER
1021+  F8AB E1          	POP	HL			; RECOVER C_SIZE
1022+  F8AC 28 1B       	JR	Z,SD_PRTINFO5		; HANDLE ZERO BIT SHIFT CASE
1023+  F8AE             SD_PRTINFO3B:
1024+  F8AE CB 2C       	SRA	H			; SHIFT MSB
1025+  F8B0 CB 1D       	RR	L			; SHIFT LSB
1026+  F8B2 10 FA       	DJNZ	SD_PRTINFO3B		; LOOP TILL DONE
1027+  F8B4 18 13       	JR	SD_PRTINFO5		; GO TO PRINT ROUTINE
1028+  F8B6             ;
1029+  F8B6             SD_PRTINFO4:	; PRINT SIZE FOR V2 CARD
1030+  F8B6 DD 7E 07    	LD	A,(IX + 7)		; GET C_SIZE MSB TO A
1031+  F8B9 E6 3F       	AND	%00111111		; ISOLATE RELEVANT BITS
1032+  F8BB DD 66 08    	LD	H,(IX + 8)		; GET NEXT BYTE TO H
1033+  F8BE DD 6E 09    	LD	L,(IX + 9)		; GET C_SIZE LSB TO L
1034+  F8C1 CB 2F       	SRA	A			; RIGHT SHIFT MSB BY ONE
1035+  F8C3 CB 1C       	RR	H			; RIGHT SHIFT NEXT BYTE BY ONE
1036+  F8C5 CB 1D       	RR	L			; RIGHT SHIFT LSB BY ONE
1037+  F8C7 18 00       	JR	SD_PRTINFO5
1038+  F8C9             ;
1039+  F8C9             SD_PRTINFO5:	; COMMON CODE TO PRINT RESULTANT SIZE (IN HL)
1040+  F8C9 CD 00 FD    	CALL	PRTDEC			; PRINT SIZE IN DECIMAL
1041+  F8CC 18 04       	JR	SD_PRTINFO7		; FINISH UP
1042+  F8CE             ;
1043+  F8CE             SD_PRTINFO6:	; UNKNOWN CARD TYPE
1044+  F8CE CD 98 FB    	PRTC('?')			; UNKNOWN SIZE
1044+  F8D1 3F          
1045+  F8D2             ;
1046+  F8D2             SD_PRTINFO7:
1047+  F8D2 CD AC FB    	PRTS("MB$")			; PRINT SIZE SUFFIX
1047+  F8D5 4D 42 24    
1048+  F8D8 DD E1       	POP	IX			; RESTORE IX
1049+  F8DA             ;	
1050+  F8DA CD F6 F5    	CALL	SD_CHKWP		; WRITE PROTECTED?
1051+  F8DD 28 08       	JR	Z,SD_PRTINFO8		; NOPE, BYPASS
1052+  F8DF CD 4B FB    	CALL	PC_SPACE		; SEPARATOR
1053+  F8E2 CD B4 FB    	PRTX(SDSTR_STWRTPROT)		; TELL THE USER
1053+  F8E5 FD FA       
1054+  F8E7             ;
1055+  F8E7             SD_PRTINFO8:
1056+  F8E7 C9          	RET				; DONE
1057+  F8E8             ;
1058+  F8E8             ; CHECK THE SD CARD, ATTEMPT TO REINITIALIZE IF NEEDED
1059+  F8E8             ;
1060+  F8E8             SD_CHKCARD:
1061+  F8E8 2A 2B FB    	LD	HL,(SD_STATPTR)		; LOAD STATUS ADDRESS
1062+  F8EB 7E          	LD	A,(HL)			; GET STATUS
1063+  F8EC B7          	OR	A			; SET FLAGS
1064+  F8ED C4 31 F7    	CALL	NZ,SD_INITCARD		; INIT CARD IF NOT READY
1065+  F8F0 C9          	RET				; RETURN WITH STATUS IN A
1066+  F8F1             
1067+  F8F1             SD_RDSEC:
1068+  F8F1 CD E8 F8    	CALL	SD_CHKCARD	; CHECK / REINIT CARD AS NEEDED
1069+  F8F4 C0          	RET	NZ
1070+  F8F5             
1071+  F8F5 CD 37 F9    	CALL	SD_SETADDR	; SETUP BLOCK ADDRESS
1072+  F8F8             
1073+  F8F8 3E 51       	LD	A,SD_CMD17	; READ_SINGLE_BLOCK
1074+  F8FA CD 07 F7    	CALL	SD_EXECCMDP	; EXEC CMD WITH BLOCK ADDRESS AS PARM
1075+  F8FD C4 44 F6    	CALL	NZ,SD_DONE	; TRANSACTION DONE IF ERROR OCCURRED
1076+  F900 F8          	RET	M		; ABORT ON PROCESSING ERROR
1077+  F901 C2 71 F9    	JP	NZ,SD_ERRCMD	; FAIL IF NON-ZERO RC
1078+  F904             	
1079+  F904 2A 49 FD    	LD	HL,(DIOBUF)
1080+  F907 01 00 02    	LD	BC,512		; LENGTH TO READ
1081+  F90A CD 4F F6    	CALL	SD_GETDATA	; GET THE BLOCK
1082+  F90D CD 44 F6    	CALL	SD_DONE
1083+  F910 C2 75 F9    	JP	NZ,SD_ERRDATA	; DATA XFER ERROR
1084+  F913 C9          	RET
1085+  F914             ;
1086+  F914             ; WRITE ONE SECTOR
1087+  F914             ;
1088+  F914             SD_WRSEC:
1089+  F914 CD E8 F8    	CALL	SD_CHKCARD	; CHECK / REINIT CARD AS NEEDED
1090+  F917 C0          	RET	NZ
1091+  F918             
1092+  F918 CD 37 F9    	CALL	SD_SETADDR	; SETUP BLOCK ADDRESS
1093+  F91B             
1094+  F91B 3E 58       	LD	A,SD_CMD24	; WRITE_BLOCK
1095+  F91D CD 07 F7    	CALL	SD_EXECCMDP	; EXEC CMD WITH BLOCK ADDRESS AS PARM
1096+  F920 C4 44 F6    	CALL	NZ,SD_DONE	; TRANSACTION DONE IF ERROR OCCURRED
1097+  F923 F8          	RET	M		; ABORT ON PROCESSING ERROR
1098+  F924 C2 71 F9    	JP	NZ,SD_ERRCMD	; FAIL IF NON-ZERO RC
1099+  F927             	
1100+  F927 2A 49 FD    	LD	HL,(DIOBUF)	; SETUP DATA SOURCE ADDRESS
1101+  F92A 01 00 02    	LD	BC,512		; LENGTH TO WRITE
1102+  F92D CD 7B F6    	CALL	SD_PUTDATA	; PUT THE BLOCK
1103+  F930 CD 44 F6    	CALL	SD_DONE
1104+  F933 C2 75 F9    	JP	NZ,SD_ERRDATA	; DATA XFER ERROR
1105+  F936 C9          	RET
1106+  F937             ;
1107+  F937             ;	
1108+  F937             ;
1109+  F937             SD_SETADDR:
1110+  F937 2A 2E FB    	LD	HL,(SD_TYPEPTR)
1111+  F93A 7E          	LD	A,(HL)
1112+  F93B FE 02       	CP	SD_TYPESDSC
1113+  F93D 28 07       	JR	Z,SD_SETADDRSDSC
1114+  F93F FE 03       	CP	SD_TYPESDHC
1115+  F941 28 19       	JR	Z,SD_SETADDRSDHC
1116+  F943 CD 23 FC    	CALL	PANIC
1117+  F946             
1118+  F946             ;
1119+  F946             ; SDSC CARDS USE A BYTE OFFSET
1120+  F946             ;
1121+  F946             ; TT:SS = BC:DE -> TS:S0, THEN LEFT SHIFT ONE BIT
1122+  F946             SD_SETADDRSDSC:
1123+  F946 ED 4B 45 FD 	LD	BC,(HSTTRK)
1124+  F94A ED 5B 47 FD 	LD	DE,(HSTSEC)
1125+  F94E 41          	LD	B,C
1126+  F94F 4A          	LD	C,D
1127+  F950 53          	LD	D,E
1128+  F951 1E 00       	LD	E,0
1129+  F953 CB 23       	SLA	E
1130+  F955 CB 12       	RL	D
1131+  F957 CB 11       	RL	C
1132+  F959 CB 10       	RL	B
1133+  F95B C9          	RET
1134+  F95C             ;
1135+  F95C             ; SDHC CARDS USE SIMPLE LBA, NO TRANSLATION NEEDED
1136+  F95C             ;
1137+  F95C             SD_SETADDRSDHC:
1138+  F95C ED 4B 45 FD 	LD	BC,(HSTTRK)	; LBA HIGH WORD
1139+  F960 ED 5B 47 FD 	LD	DE,(HSTSEC)	; LBA LOW WORD
1140+  F964 C9          	RET			; DONE
1141+  F965             ;
1142+  F965             ; HANDLE READY TIMEOUT ERROR
1143+  F965             ;
1144+  F965             SD_ERRRDYTO:
1145+  F965 3E FE       	LD	A,SD_STRDYTO
1146+  F967 18 20       	JR	SD_CARDERR
1147+  F969             ;
1148+  F969             SD_ERRINITTO:
1149+  F969 3E FD       	LD	A,SD_STINITTO
1150+  F96B 18 1C       	JR	SD_CARDERR
1151+  F96D             ;
1152+  F96D             SD_ERRCMDTO:
1153+  F96D 3E FC       	LD	A,SD_STCMDTO
1154+  F96F 18 18       	JR	SD_CARDERR
1155+  F971             ;
1156+  F971             SD_ERRCMD:
1157+  F971 3E FB       	LD	A,SD_STCMDERR
1158+  F973 18 14       	JR	SD_CARDERR
1159+  F975             ;
1160+  F975             SD_ERRDATA:
1161+  F975 3E FA       	LD	A,SD_STDATAERR
1162+  F977 18 10       	JR	SD_CARDERR
1163+  F979             ;
1164+  F979             SD_ERRDATATO:
1165+  F979 3E F9       	LD	A,SD_STDATATO
1166+  F97B 18 0C       	JR	SD_CARDERR
1167+  F97D             ;
1168+  F97D             SD_ERRCRC:
1169+  F97D 3E F8       	LD	A,SD_STCRCERR
1170+  F97F 18 08       	JR	SD_CARDERR
1171+  F981             ;
1172+  F981             SD_NOMEDIA:
1173+  F981 3E F7       	LD	A,SD_STNOMEDIA
1174+  F983 18 04       	JR	SD_CARDERR
1175+  F985             ;
1176+  F985             SD_WRTPROT:
1177+  F985 3E F6       	LD	A,SD_STWRTPROT
1178+  F987 18 00       	JR	SD_CARDERR
1179+  F989             ;
1180+  F989             ; GENERIC ERROR HANDLER
1181+  F989             ;
1182+  F989             SD_CARDERR:
1183+  F989 E5          	PUSH	HL			; IS THIS NEEDED?
1184+  F98A 2A 2B FB    	LD	HL,(SD_STATPTR)
1185+  F98D 77          	LD	(HL),A
1186+  F98E E1          	POP	HL			; IS THIS NEEDED?
1187+  F98F~            #IF (SDTRACE >= 2)
1188+  F98F~            	CALL	NEWLINE
1189+  F98F~            	PUSH	AF			; IS THIS NEEDED?
1190+  F98F~            	PRTC('<')
1190+  F98F~            	PRTC('<')
1191+  F98F~            	CALL	SD_PRTSTAT
1192+  F98F~            	PRTC('>')
1192+  F98F~            	PRTC('>')
1193+  F98F~            	POP	AF			; IS THIS NEEDED?
1194+  F98F             #ENDIF
1195+  F98F B7          	OR	A
1196+  F990 C9          	RET
1197+  F991             ;
1198+  F991             ; PRINT DIAGNONSTIC PREFIX
1199+  F991             ;
1200+  F991             SD_PRTPREFIX:
1201+  F991 CD 91 FB    	CALL	NEWLINE
1202+  F994 11 56 FA    	LD	DE,SDSTR_PREFIX
1203+  F997 CD 13 FC    	CALL	WRITESTR
1204+  F99A F5          	PUSH	AF
1205+  F99B 3A 30 FB    	LD	A,(SD_UNIT)
1206+  F99E C6 30       	ADD	A,'0'
1207+  F9A0 CD 72 FC    	CALL	COUT
1208+  F9A3 F1          	POP	AF
1209+  F9A4 CD 55 FB    	CALL	PC_COLON
1210+  F9A7 C9          	RET
1211+  F9A8             ;
1212+  F9A8             ; PRINT STATUS STRING
1213+  F9A8             ;
1214+  F9A8             SD_PRTSTAT:
1215+  F9A8 E5          	PUSH	HL			; IS THIS NEEDED?
1216+  F9A9 2A 2B FB    	LD	HL,(SD_STATPTR)
1217+  F9AC 7E          	LD	A,(HL)
1218+  F9AD E1          	POP	HL			; IS THIS NEEDED?
1219+  F9AE B7          	OR	A
1220+  F9AF 11 73 FA    	LD	DE,SDSTR_STOK
1221+  F9B2 28 3F       	JR	Z,SD_PRTSTAT1
1222+  F9B4 3C          	INC	A
1223+  F9B5 11 85 FA    	LD	DE,SDSTR_STNOTRDY
1224+  F9B8 28 39       	JR	Z,SD_PRTSTAT1
1225+  F9BA 3C          	INC	A
1226+  F9BB 11 8F FA    	LD	DE,SDSTR_STRDYTO
1227+  F9BE 28 33       	JR	Z,SD_PRTSTAT1
1228+  F9C0 3C          	INC	A
1229+  F9C1 11 9D FA    	LD	DE,SDSTR_STINITTO
1230+  F9C4 28 2D       	JR	Z,SD_PRTSTAT1
1231+  F9C6 3C          	INC	A
1232+  F9C7 11 B4 FA    	LD	DE,SDSTR_STCMDTO
1233+  F9CA 28 27       	JR	Z,SD_PRTSTAT1
1234+  F9CC 3C          	INC	A
1235+  F9CD 11 C4 FA    	LD	DE,SDSTR_STCMDERR
1236+  F9D0 28 21       	JR	Z,SD_PRTSTAT1
1237+  F9D2 3C          	INC	A
1238+  F9D3 11 D2 FA    	LD	DE,SDSTR_STDATAERR
1239+  F9D6 28 1B       	JR	Z,SD_PRTSTAT1
1240+  F9D8 3C          	INC	A
1241+  F9D9 11 DD FA    	LD	DE,SDSTR_STDATATO
1242+  F9DC 28 15       	JR	Z,SD_PRTSTAT1
1243+  F9DE 3C          	INC	A
1244+  F9DF 11 EA FA    	LD	DE,SDSTR_STCRCERR
1245+  F9E2 28 0F       	JR	Z,SD_PRTSTAT1
1246+  F9E4 3C          	INC	A
1247+  F9E5 11 F4 FA    	LD	DE,SDSTR_STNOMEDIA
1248+  F9E8 28 09       	JR	Z,SD_PRTSTAT1
1249+  F9EA 3C          	INC	A
1250+  F9EB 11 FD FA    	LD	DE,SDSTR_STWRTPROT
1251+  F9EE 28 03       	JR	Z,SD_PRTSTAT1
1252+  F9F0 11 0D FB    	LD	DE,SDSTR_STUNK
1253+  F9F3             ;
1254+  F9F3             SD_PRTSTAT1:
1255+  F9F3 CD 13 FC    	CALL	WRITESTR
1256+  F9F6 E5          	PUSH	HL			; IS THIS NEEDED?
1257+  F9F7 2A 2B FB    	LD	HL,(SD_STATPTR)
1258+  F9FA 7E          	LD	A,(HL)
1259+  F9FB E1          	POP	HL			; IS THIS NEEDED?
1260+  F9FC FE FB       	CP	SD_STCMDERR
1261+  F9FE 28 05       	JR	Z,SD_PRTCMDERR
1262+  FA00 FE FA       	CP	SD_STDATAERR
1263+  FA02 28 06       	JR	Z,SD_PRTDATAERR
1264+  FA04 C9          	RET
1265+  FA05             ;
1266+  FA05             SD_PRTCMDERR:
1267+  FA05 3A 31 FB    	LD	A,(SD_RC)
1268+  FA08 18 05       	JR	SD_PRTCODE
1269+  FA0A             ;
1270+  FA0A             SD_PRTDATAERR:
1271+  FA0A 3A 32 FB    	LD	A,(SD_TOK)
1272+  FA0D 18 00       	JR	SD_PRTCODE
1273+  FA0F             ;
1274+  FA0F             SD_PRTCODE:
1275+  FA0F CD 73 FB    	CALL	PC_LPAREN
1276+  FA12 F5          	PUSH	AF
1277+  FA13 3A 45 FB    	LD	A,(SD_CMD)
1278+  FA16 CD C3 FB    	CALL	PRTHEXBYTE
1279+  FA19 11 59 FA    	LD	DE,SDSTR_ARROW
1280+  FA1C CD 13 FC    	CALL	WRITESTR
1281+  FA1F F1          	POP	AF
1282+  FA20 CD C3 FB    	CALL	PRTHEXBYTE
1283+  FA23 CD 78 FB    	CALL	PC_RPAREN
1284+  FA26 C9          	RET
1285+  FA27             ;
1286+  FA27             ; PRT COMMAND TRACE
1287+  FA27             ;
1288+  FA27             SD_PRTTRN:
1289+  FA27 F5          	PUSH	AF
1290+  FA28             	
1291+  FA28 CD 91 F9    	CALL	SD_PRTPREFIX
1292+  FA2B             
1293+  FA2B 11 45 FB    	LD	DE,SD_CMDBUF
1294+  FA2E 3E 06       	LD	A,6
1295+  FA30 CD F6 FB    	CALL	PRTHEXBUF
1296+  FA33 11 59 FA    	LD	DE,SDSTR_ARROW
1297+  FA36 CD 13 FC    	CALL	WRITESTR
1298+  FA39             
1299+  FA39 11 5E FA    	LD	DE,SDSTR_RC
1300+  FA3C CD 13 FC    	CALL	WRITESTR
1301+  FA3F 3A 31 FB    	LD	A,(SD_RC)
1302+  FA42 CD C3 FB    	CALL	PRTHEXBYTE
1303+  FA45 CD 4B FB    	CALL	PC_SPACE
1304+  FA48             	
1305+  FA48 11 62 FA    	LD	DE,SDSTR_TOK
1306+  FA4B CD 13 FC    	CALL	WRITESTR
1307+  FA4E 3A 32 FB    	LD	A,(SD_TOK)
1308+  FA51 CD C3 FB    	CALL	PRTHEXBYTE
1309+  FA54             	
1310+  FA54 F1          	POP	AF
1311+  FA55             
1312+  FA55 C9          	RET
1313+  FA56             
1314+  FA56             ;
1315+  FA56             ; DISPLAY COMMAND, LOW ORDER WORD OF PARMS, AND RC
1316+  FA56             ;
1317+  FA56~            #IF (DSKYENABLE)
1318+  FA56~            SD_DSKY:
1319+  FA56~            	PUSH	AF
1320+  FA56~            	LD	HL,DSKY_HEXBUF
1321+  FA56~            	LD	A,(SD_CMD)
1322+  FA56~            	LD	(HL),A
1323+  FA56~            	INC	HL
1324+  FA56~            	LD	A,(SD_CMDP2)
1325+  FA56~            	LD	(HL),A
1326+  FA56~            	INC	HL
1327+  FA56~            	LD	A,(SD_CMDP3)
1328+  FA56~            	LD	(HL),A
1329+  FA56~            	INC	HL
1330+  FA56~            	LD	A,(SD_RC)
1331+  FA56~            	CALL	DSKY_HEXOUT
1332+  FA56~            	POP	AF
1333+  FA56~            	RET
1334+  FA56             #ENDIF
1335+  FA56             ;
1336+  FA56             ;
1337+  FA56             ;
1338+  FA56 53 44 24    SDSTR_PREFIX	.TEXT	"SD$"
1339+  FA59 20 2D 3E 20 SDSTR_ARROW	.TEXT	" -> $"
1339+  FA5D 24 
1340+  FA5E 52 43 3D 24 SDSTR_RC	.TEXT	"RC=$"
1341+  FA62 54 4F 4B 3D SDSTR_TOK	.TEXT	"TOK=$"
1341+  FA66 24 
1342+  FA67 20 43 53 44 SDSTR_CSD	.TEXT	" CSD=$"
1342+  FA6B 3D 24 
1343+  FA6D 20 43 49 44 SDSTR_CID	.TEXT	" CID=$"
1343+  FA71 3D 24 
1344+  FA73 4F 4B 24    SDSTR_STOK	.TEXT	"OK$"
1345+  FA76 53 44 20 43 SDSTR_SDTYPE	.TEXT	"SD CARD TYPE: $"
1345+  FA7A 41 52 44 20 
1345+  FA7E 54 59 50 45 
1345+  FA82 3A 20 24 
1346+  FA85             ;
1347+  FA85 4E 4F 54 20 SDSTR_STNOTRDY	.TEXT	"NOT READY$"
1347+  FA89 52 45 41 44 
1347+  FA8D 59 24 
1348+  FA8F 52 45 41 44 SDSTR_STRDYTO	.TEXT	"READY TIMEOUT$"
1348+  FA93 59 20 54 49 
1348+  FA97 4D 45 4F 55 
1348+  FA9B 54 24 
1349+  FA9D 49 4E 49 54 SDSTR_STINITTO	.TEXT	"INITIALIZATION TIMEOUT$"
1349+  FAA1 49 41 4C 49 
1349+  FAA5 5A 41 54 49 
1349+  FAA9 4F 4E 20 54 
1349+  FAAD 49 4D 45 4F 
1349+  FAB1 55 54 24 
1350+  FAB4 43 4F 4D 4D SDSTR_STCMDTO	.TEXT	"COMMAND TIMEOUT$"
1350+  FAB8 41 4E 44 20 
1350+  FABC 54 49 4D 45 
1350+  FAC0 4F 55 54 24 
1351+  FAC4 43 4F 4D 4D SDSTR_STCMDERR	.TEXT	"COMMAND ERROR$"
1351+  FAC8 41 4E 44 20 
1351+  FACC 45 52 52 4F 
1351+  FAD0 52 24 
1352+  FAD2 44 41 54 41 SDSTR_STDATAERR	.TEXT	"DATA ERROR$"
1352+  FAD6 20 45 52 52 
1352+  FADA 4F 52 24 
1353+  FADD 44 41 54 41 SDSTR_STDATATO	.TEXT	"DATA TIMEOUT$"
1353+  FAE1 20 54 49 4D 
1353+  FAE5 45 4F 55 54 
1353+  FAE9 24 
1354+  FAEA 43 52 43 20 SDSTR_STCRCERR	.TEXT	"CRC ERROR$"
1354+  FAEE 45 52 52 4F 
1354+  FAF2 52 24 
1355+  FAF4 4E 4F 20 4D SDSTR_STNOMEDIA	.TEXT	"NO MEDIA$"
1355+  FAF8 45 44 49 41 
1355+  FAFC 24 
1356+  FAFD 57 52 49 54 SDSTR_STWRTPROT	.TEXT	"WRITE PROTECTED$"
1356+  FB01 45 20 50 52 
1356+  FB05 4F 54 45 43 
1356+  FB09 54 45 44 24 
1357+  FB0D 55 4E 4B 4E SDSTR_STUNK	.TEXT	"UNKNOWN$"
1357+  FB11 4F 57 4E 24 
1358+  FB15 55 4E 4B 24 SDSTR_TYPEUNK	.TEXT	"UNK$"
1359+  FB19 4D 4D 43 24 SDSTR_TYPEMMC	.TEXT	"MMC$"
1360+  FB1D 53 44 53 43 SDSTR_TYPESDSC	.TEXT	"SDSC$"
1360+  FB21 24 
1361+  FB22 53 44 48 43 SDSTR_TYPESDHC	.TEXT	"SDHC/XC$"
1361+  FB26 2F 58 43 24 
1362+  FB2A             ;
1363+  FB2A             ;==================================================================================================
1364+  FB2A             ;   SD DISK DRIVER - DATA
1365+  FB2A             ;==================================================================================================
1366+  FB2A             ;
1367+  FB2A 00          SD_STATLST	.FILL	SD_UNITCNT,0	; LIST OF UNIT STATUSES (2 UNITS)
1368+  FB2B 2A FB       SD_STATPTR	.DW	SD_STATLST	; ADDRESS OF STATUS FOR CURRENT UNIT
1369+  FB2D 00          SD_TYPELST	.FILL	SD_UNITCNT,0	; LIST OF CARD TYPES (2 UNITS)
1370+  FB2E 2D FB       SD_TYPEPTR	.Dw	SD_TYPELST	; ADDRESS OF CARD TYPE FOR CURRENT UNIT
1371+  FB30 00          SD_UNIT		.DB	0		; CURRENT UNIT NUMBER
1372+  FB31 00          SD_RC		.DB	0		; RETURN CODE FROM CMD
1373+  FB32 00          SD_TOK		.DB	0		; TOKEN FROM DATA XFR
1374+  FB33 00          SD_OPRVAL	.DB	0		; CURRENT OPR REG VALUE
1375+  FB34 00          SD_LCNT		.DB	0		; LOOP COUNTER
1376+  FB35             ;
1377+  FB35 00 00 00 00 SD_BUF		.FILL	16,0		; WORK BUFFER
1377+  FB39 00 00 00 00 
1377+  FB3D 00 00 00 00 
1377+  FB41 00 00 00 00 
1378+  FB45             ;
1379+  FB45             SD_CMDBUF:				; START OF STD CMD BUF
1380+  FB45 00          SD_CMD		.DB	0
1381+  FB46 00          SD_CMDP0	.DB	0
1382+  FB47 00          SD_CMDP1	.DB	0
1383+  FB48 00          SD_CMDP2	.DB	0
1384+  FB49 00          SD_CMDP3	.DB	0
1385+  FB4A 00          SD_CMDCRC	.DB	0
0350   FB4B             SIZ_SD		.EQU	$ - ORG_SD
0351   FB4B             		.ECHO	"SD occupies "
0352   FB4B             		.ECHO	SIZ_SD
0353   FB4B             		.ECHO	" bytes.\n"
0354   FB4B             #ENDIF
0355   FB4B             ;
0356   FB4B             #DEFINE	CIOMODE_CONSOLE
0357   FB4B             #DEFINE	DSKY_KBD
0358   FB4B             #INCLUDE "util.asm"
0001+  FB4B             ;
0002+  FB4B             ;==================================================================================================
0003+  FB4B             ; UTILITY FUNCTIONS
0004+  FB4B             ;==================================================================================================
0005+  FB4B             ;
0006+  FB4B             ;
0007+  FB4B             CHR_CR		.EQU	0DH
0008+  FB4B             CHR_LF		.EQU	0AH
0009+  FB4B             CHR_BS		.EQU	08H
0010+  FB4B             CHR_ESC		.EQU	1BH
0011+  FB4B             ;
0012+  FB4B             ;__________________________________________________________________________________________________
0013+  FB4B             ;
0014+  FB4B             ; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
0015+  FB4B             ;
0016+  FB4B             PC_SPACE:
0017+  FB4B F5          	PUSH	AF
0018+  FB4C 3E 20       	LD	A,' '
0019+  FB4E 18 3C       	JR	PC_PRTCHR
0020+  FB50             
0021+  FB50             PC_PERIOD:
0022+  FB50 F5          	PUSH	AF
0023+  FB51 3E 2E       	LD	A,'.'
0024+  FB53 18 37       	JR	PC_PRTCHR
0025+  FB55             
0026+  FB55             PC_COLON:
0027+  FB55 F5          	PUSH	AF
0028+  FB56 3E 3A       	LD	A,':'
0029+  FB58 18 32       	JR	PC_PRTCHR
0030+  FB5A             
0031+  FB5A             PC_COMMA:
0032+  FB5A F5          	PUSH	AF
0033+  FB5B 3E 2C       	LD	A,','
0034+  FB5D 18 2D       	JR	PC_PRTCHR
0035+  FB5F             
0036+  FB5F             PC_LBKT:
0037+  FB5F F5          	PUSH	AF
0038+  FB60 3E 5B       	LD	A,'['
0039+  FB62 18 28       	JR	PC_PRTCHR
0040+  FB64             
0041+  FB64             PC_RBKT:
0042+  FB64 F5          	PUSH	AF
0043+  FB65 3E 5D       	LD	A,']'
0044+  FB67 18 23       	JR	PC_PRTCHR
0045+  FB69             
0046+  FB69             PC_LT:
0047+  FB69 F5          	PUSH	AF
0048+  FB6A 3E 3C       	LD	A,'<'
0049+  FB6C 18 1E       	JR	PC_PRTCHR
0050+  FB6E             
0051+  FB6E             PC_GT:
0052+  FB6E F5          	PUSH	AF
0053+  FB6F 3E 3E       	LD	A,'>'
0054+  FB71 18 19       	JR	PC_PRTCHR
0055+  FB73             
0056+  FB73             PC_LPAREN:
0057+  FB73 F5          	PUSH	AF
0058+  FB74 3E 28       	LD	A,'('
0059+  FB76 18 14       	JR	PC_PRTCHR
0060+  FB78             
0061+  FB78             PC_RPAREN:
0062+  FB78 F5          	PUSH	AF
0063+  FB79 3E 29       	LD	A,')'
0064+  FB7B 18 0F       	JR	PC_PRTCHR
0065+  FB7D             
0066+  FB7D             PC_ASTERISK:
0067+  FB7D F5          	PUSH	AF
0068+  FB7E 3E 2A       	LD	A,'*'
0069+  FB80 18 0A       	JR	PC_PRTCHR
0070+  FB82             
0071+  FB82             PC_CR:
0072+  FB82 F5          	PUSH	AF
0073+  FB83 3E 0D       	LD	A,CHR_CR
0074+  FB85 18 05       	JR	PC_PRTCHR
0075+  FB87             
0076+  FB87             PC_LF:
0077+  FB87 F5          	PUSH	AF
0078+  FB88 3E 0A       	LD	A,CHR_LF
0079+  FB8A 18 00       	JR	PC_PRTCHR
0080+  FB8C             
0081+  FB8C             PC_PRTCHR:
0082+  FB8C CD 72 FC    	CALL	COUT
0083+  FB8F F1          	POP	AF
0084+  FB90 C9          	RET
0085+  FB91             
0086+  FB91             NEWLINE:
0087+  FB91 CD 82 FB    	CALL	PC_CR
0088+  FB94 CD 87 FB    	CALL	PC_LF
0089+  FB97 C9          	RET
0090+  FB98             ;
0091+  FB98             ; PRINT A CHARACTER REFERENCED BY POINTER AT TOP OF STACK
0092+  FB98             ; USAGE:
0093+  FB98             ;   CALL PRTCH
0094+  FB98             ;   .DB  'X'
0095+  FB98             ;
0096+  FB98             PRTCH:
0097+  FB98 E3          	EX	(SP),HL
0098+  FB99 F5          	PUSH	AF
0099+  FB9A 7E          	LD	A,(HL)
0100+  FB9B CD 72 FC    	CALL	COUT
0101+  FB9E F1          	POP	AF
0102+  FB9F 23          	INC	HL
0103+  FBA0 E3          	EX	(SP),HL
0104+  FBA1 C9          	RET
0105+  FBA2             ;
0106+  FBA2             ; PRINT A STRING AT ADDRESS SPECIFIED IN HL
0107+  FBA2             ; STRING MUST BE TERMINATED BY '$'
0108+  FBA2             ; USAGE:
0109+  FBA2             ;   LD	HL,MYSTR
0110+  FBA2             ;   CALL PRTSTR
0111+  FBA2             ;   ...
0112+  FBA2             ;   MYSTR: .DB  "HELLO$"
0113+  FBA2             ;
0114+  FBA2             PRTSTR:
0115+  FBA2 7E          	LD	A,(HL)
0116+  FBA3 23          	INC	HL
0117+  FBA4 FE 24       	CP	'$'
0118+  FBA6 C8          	RET	Z
0119+  FBA7 CD 72 FC    	CALL	COUT
0120+  FBAA 18 F6       	JR	PRTSTR
0121+  FBAC             ;
0122+  FBAC             ; PRINT A STRING DIRECT: REFERENCED BY POINTER AT TOP OF STACK
0123+  FBAC             ; STRING MUST BE TERMINATED BY '$'
0124+  FBAC             ; USAGE:
0125+  FBAC             ;   CALL PRTSTR
0126+  FBAC             ;   .DB  "HELLO$"
0127+  FBAC             ;   ...
0128+  FBAC             ;
0129+  FBAC             PRTSTRD:
0130+  FBAC E3          	EX	(SP),HL
0131+  FBAD F5          	PUSH	AF
0132+  FBAE CD A2 FB    	CALL	PRTSTR
0133+  FBB1 F1          	POP	AF
0134+  FBB2 E3          	EX	(SP),HL
0135+  FBB3 C9          	RET
0136+  FBB4             ;
0137+  FBB4             ; PRINT A STRING INDIRECT: REFERENCED BY INDIRECT POINTER AT TOP OF STACK
0138+  FBB4             ; STRING MUST BE TERMINATED BY '$'
0139+  FBB4             ; USAGE:
0140+  FBB4             ;   CALL PRTSTRI(MYSTRING)
0141+  FBB4             ;   MYSTRING	.DB	"HELLO$"
0142+  FBB4             ;
0143+  FBB4             PRTSTRI:
0144+  FBB4 E3          	EX	(SP),HL
0145+  FBB5 F5          	PUSH	AF
0146+  FBB6 7E          	LD	A,(HL)
0147+  FBB7 23          	INC	HL
0148+  FBB8 E5          	PUSH	HL
0149+  FBB9 66          	LD	H,(HL)
0150+  FBBA 6F          	LD	L,A
0151+  FBBB CD A2 FB    	CALL	PRTSTR
0152+  FBBE E1          	POP	HL
0153+  FBBF 23          	INC	HL
0154+  FBC0 F1          	POP	AF
0155+  FBC1 E3          	EX	(SP),HL
0156+  FBC2 C9          	RET
0157+  FBC3             ;
0158+  FBC3             ; PRINT THE HEX BYTE VALUE IN A
0159+  FBC3             ;
0160+  FBC3             PRTHEXBYTE:
0161+  FBC3 F5          	PUSH	AF
0162+  FBC4 D5          	PUSH	DE
0163+  FBC5 CD DE FB    	CALL	HEXASCII
0164+  FBC8 7A          	LD	A,D
0165+  FBC9 CD 72 FC    	CALL	COUT
0166+  FBCC 7B          	LD	A,E
0167+  FBCD CD 72 FC    	CALL	COUT
0168+  FBD0 D1          	POP	DE
0169+  FBD1 F1          	POP	AF
0170+  FBD2 C9          	RET
0171+  FBD3             ;
0172+  FBD3             ; PRINT THE HEX WORD VALUE IN BC
0173+  FBD3             ;
0174+  FBD3             PRTHEXWORD:
0175+  FBD3 F5          	PUSH	AF
0176+  FBD4 78          	LD	A,B
0177+  FBD5 CD C3 FB    	CALL	PRTHEXBYTE
0178+  FBD8 79          	LD	A,C
0179+  FBD9 CD C3 FB    	CALL	PRTHEXBYTE
0180+  FBDC F1          	POP	AF
0181+  FBDD C9          	RET
0182+  FBDE             ;
0183+  FBDE             ; CONVERT BINARY VALUE IN A TO ASCII HEX CHARACTERS IN DE
0184+  FBDE             ;
0185+  FBDE             HEXASCII:
0186+  FBDE 57          	LD	D,A
0187+  FBDF CD ED FB    	CALL	HEXCONV
0188+  FBE2 5F          	LD	E,A
0189+  FBE3 7A          	LD	A,D
0190+  FBE4 07          	RLCA
0191+  FBE5 07          	RLCA
0192+  FBE6 07          	RLCA
0193+  FBE7 07          	RLCA
0194+  FBE8 CD ED FB    	CALL	HEXCONV
0195+  FBEB 57          	LD	D,A
0196+  FBEC C9          	RET
0197+  FBED             ;
0198+  FBED             ; CONVERT LOW NIBBLE OF A TO ASCII HEX
0199+  FBED             ;
0200+  FBED             HEXCONV:
0201+  FBED E6 0F       	AND	0FH	     ;LOW NIBBLE ONLY
0202+  FBEF C6 90       	ADD	A,90H
0203+  FBF1 27          	DAA	
0204+  FBF2 CE 40       	ADC	A,40H
0205+  FBF4 27          	DAA	
0206+  FBF5 C9          	RET	
0207+  FBF6             ;
0208+  FBF6             ; PRINT A BYTE BUFFER IN HEX POINTED TO BY DE
0209+  FBF6             ; REGISTER A HAS SIZE OF BUFFER
0210+  FBF6             ;
0211+  FBF6             PRTHEXBUF:
0212+  FBF6 FE 00       	CP	0		; EMPTY BUFFER?
0213+  FBF8 CA 09 FC    	JP	Z,PRTHEXBUF2
0214+  FBFB             	
0215+  FBFB 47          	LD	B,A
0216+  FBFC             PRTHEXBUF1:
0217+  FBFC CD 4B FB    	CALL	PC_SPACE
0218+  FBFF 1A          	LD	A,(DE)
0219+  FC00 CD C3 FB    	CALL	PRTHEXBYTE
0220+  FC03 13          	INC	DE
0221+  FC04 10 F6       	DJNZ	PRTHEXBUF1
0222+  FC06 C3 12 FC    	JP	PRTHEXBUFX
0223+  FC09             	
0224+  FC09             PRTHEXBUF2:
0225+  FC09 CD 4B FB    	CALL	PC_SPACE
0226+  FC0C 11 2D FD    	LD	DE,STR_EMPTY
0227+  FC0F CD 13 FC    	CALL	WRITESTR
0228+  FC12             
0229+  FC12             PRTHEXBUFX:
0230+  FC12 C9          	RET
0231+  FC13             ;
0232+  FC13             ; OUTPUT A '$' TERMINATED STRING
0233+  FC13             ;
0234+  FC13             WRITESTR:
0235+  FC13 F5          	PUSH	AF
0236+  FC14             WRITESTR1:
0237+  FC14 1A          	LD	A,(DE)
0238+  FC15 FE 24       	CP	'$'			; TEST FOR STRING TERMINATOR
0239+  FC17 CA 21 FC    	JP	Z,WRITESTR2
0240+  FC1A CD 72 FC    	CALL	COUT
0241+  FC1D 13          	INC	DE
0242+  FC1E C3 14 FC    	JP	WRITESTR1
0243+  FC21             WRITESTR2:
0244+  FC21 F1          	POP	AF
0245+  FC22 C9          	RET
0246+  FC23             ;
0247+  FC23             ; PANIC: TRY TO DUMP MACHINE STATE AND HALT
0248+  FC23             ;
0249+  FC23             PANIC:
0250+  FC23 E5          	PUSH	HL
0251+  FC24 D5          	PUSH	DE
0252+  FC25 C5          	PUSH	BC
0253+  FC26 F5          	PUSH	AF
0254+  FC27 11 A6 FC    	LD	DE,STR_PANIC
0255+  FC2A CD 13 FC    	CALL	WRITESTR
0256+  FC2D 11 BB FC    	LD	DE,STR_AF
0257+  FC30 CD 13 FC    	CALL	WRITESTR
0258+  FC33 C1          	POP	BC		; AF
0259+  FC34 CD D3 FB    	CALL	PRTHEXWORD
0260+  FC37 11 C0 FC    	LD	DE,STR_BC
0261+  FC3A CD 13 FC    	CALL	WRITESTR
0262+  FC3D C1          	POP	BC		; BC
0263+  FC3E CD D3 FB    	CALL	PRTHEXWORD
0264+  FC41 11 C5 FC    	LD	DE,STR_DE
0265+  FC44 CD 13 FC    	CALL	WRITESTR
0266+  FC47 C1          	POP	BC		; DE
0267+  FC48 CD D3 FB    	CALL	PRTHEXWORD
0268+  FC4B 11 CA FC    	LD	DE,STR_HL
0269+  FC4E CD 13 FC    	CALL	WRITESTR
0270+  FC51 C1          	POP	BC		; HL
0271+  FC52 CD D3 FB    	CALL	PRTHEXWORD
0272+  FC55 11 CF FC    	LD	DE,STR_PC
0273+  FC58 CD 13 FC    	CALL	WRITESTR
0274+  FC5B C1          	POP	BC		; PC
0275+  FC5C CD D3 FB    	CALL	PRTHEXWORD
0276+  FC5F 11 D4 FC    	LD	DE,STR_SP
0277+  FC62 CD 13 FC    	CALL	WRITESTR
0278+  FC65 21 00 00    	LD	HL,0
0279+  FC68 39          	ADD	HL,SP		; SP
0280+  FC69 44          	LD	B,H
0281+  FC6A 4D          	LD	C,L
0282+  FC6B CD D3 FB    	CALL	PRTHEXWORD
0283+  FC6E             	
0284+  FC6E FF          	RST	38
0285+  FC6F             	
0286+  FC6F C3 00 00    	JP	0
0287+  FC72             ;
0288+  FC72             ;==================================================================================================
0289+  FC72             ; CONSOLE CHARACTER I/O HELPER ROUTINES (REGISTERS PRESERVED)
0290+  FC72             ;==================================================================================================
0291+  FC72             ;
0292+  FC72             ; OUTPUT CHARACTER FROM A
0293+  FC72             COUT:
0294+  FC72 F5          	PUSH	AF
0295+  FC73 C5          	PUSH	BC
0296+  FC74 D5          	PUSH	DE
0297+  FC75 E5          	PUSH	HL
0298+  FC76             #IFDEF CIOMODE_CONSOLE
0299+  FC76               #DEFINE CIOMODE_NONDOS
0300+  FC76 5F          	LD	E,A
0301+  FC77 3A 42 FD    	LD	A,(CONDEV)
0302+  FC7A 4F          	LD	C,A
0303+  FC7B 06 01       	LD	B,BF_CIOOUT
0304+  FC7D CD 78 F0    	CALL	BIOS_DISPATCH
0305+  FC80             #ENDIF
0306+  FC80~            #IFDEF CIOMODE_HBIOS
0307+  FC80~              #DEFINE CIOMODE_NONDOS
0308+  FC80~            	LD	E,A
0309+  FC80~            	LD	A,DEFCON
0310+  FC80~            	LD	C,A
0311+  FC80~            	LD	B,BF_CIOOUT
0312+  FC80~            	RST	08
0313+  FC80             #ENDIF
0314+  FC80~            #IFDEF CIOMODE_CBIOS
0315+  FC80~              #DEFINE CIOMODE_NONDOS
0316+  FC80~            	LD	C,A
0317+  FC80~            	CALL	CBIOS_CONOUT
0318+  FC80             #ENDIF
0319+  FC80~            #IFNDEF CIOMODE_NONDOS
0320+  FC80~            	LD	E,A
0321+  FC80~            	LD	C,03H
0322+  FC80~            	CALL	0005H
0323+  FC80             #ENDIF
0324+  FC80 E1          	POP	HL
0325+  FC81 D1          	POP	DE
0326+  FC82 C1          	POP	BC
0327+  FC83 F1          	POP	AF
0328+  FC84 C9          	RET
0329+  FC85             ;
0330+  FC85             ; INPUT CHARACTER TO A
0331+  FC85             ;
0332+  FC85             CIN:
0333+  FC85 C5          	PUSH	BC
0334+  FC86 D5          	PUSH	DE
0335+  FC87 E5          	PUSH	HL
0336+  FC88             #IFDEF CIOMODE_CONSOLE
0337+  FC88               #DEFINE CIOMODE_NONDOS
0338+  FC88 3A 42 FD    	LD	A,(CONDEV)
0339+  FC8B 4F          	LD	C,A
0340+  FC8C 06 00       	LD	B,BF_CIOIN
0341+  FC8E CD 78 F0    	CALL	BIOS_DISPATCH
0342+  FC91 7B          	LD	A,E
0343+  FC92             #ENDIF
0344+  FC92~            #IFDEF CIOMODE_HBIOS
0345+  FC92~              #DEFINE CIOMODE_NONDOS
0346+  FC92~            	LD	A,DEFCON
0347+  FC92~            	LD	C,A
0348+  FC92~            	LD	B,BF_CIOIN
0349+  FC92~            	RST	08
0350+  FC92~            	LD	A,E
0351+  FC92             #ENDIF
0352+  FC92~            #IFDEF CIOMODE_CBIOS
0353+  FC92~              #DEFINE CIOMODE_NONDOS
0354+  FC92~            	CALL	CBIOS_CONIN
0355+  FC92             #ENDIF
0356+  FC92~            #IFNDEF CIOMODE_NONDOS
0357+  FC92~            	LD	C,01H
0358+  FC92~            	CALL	0005H
0359+  FC92             #ENDIF
0360+  FC92 E1          	POP	HL
0361+  FC93 D1          	POP	DE
0362+  FC94 C1          	POP	BC
0363+  FC95 C9          	RET
0364+  FC96             ;
0365+  FC96             ; RETURN INPUT STATUS IN A (0 = NO CHAR, !=0 CHAR WAITING)
0366+  FC96             ;
0367+  FC96             CST:
0368+  FC96 C5          	PUSH	BC
0369+  FC97 D5          	PUSH	DE
0370+  FC98 E5          	PUSH	HL
0371+  FC99             #IFDEF CIOMODE_CONSOLE
0372+  FC99               #DEFINE CIOMODE_NONDOS
0373+  FC99 06 02       	LD	B,BF_CIOIST
0374+  FC9B 3A 42 FD    	LD	A,(CONDEV)
0375+  FC9E 4F          	LD	C,A
0376+  FC9F CD 78 F0    	CALL	BIOS_DISPATCH
0377+  FCA2             #ENDIF
0378+  FCA2~            #IFDEF CIOMODE_HBIOS
0379+  FCA2~              #DEFINE CIOMODE_NONDOS
0380+  FCA2~            	LD	B,BF_CIOIST
0381+  FCA2~            	LD	A,DEFCON
0382+  FCA2~            	LD	C,A
0383+  FCA2~            	RST	08
0384+  FCA2             #ENDIF
0385+  FCA2~            #IFDEF CIOMODE_CBIOS
0386+  FCA2~              #DEFINE CIOMODE_NONDOS
0387+  FCA2~            	CALL	CBIOS_CONST
0388+  FCA2             #ENDIF
0389+  FCA2~            #IFNDEF CIOMODE_NONDOS
0390+  FCA2~            	LD	C,0BH
0391+  FCA2~            	CALL	0005H
0392+  FCA2             #ENDIF
0393+  FCA2 E1          	POP	HL
0394+  FCA3 D1          	POP	DE
0395+  FCA4 C1          	POP	BC
0396+  FCA5 C9          	RET
0397+  FCA6             ;
0398+  FCA6 0D 0A 0D 0A STR_PANIC	.DB	"\r\n\r\n>>> FATAL ERROR:$"
0398+  FCAA 3E 3E 3E 20 
0398+  FCAE 46 41 54 41 
0398+  FCB2 4C 20 45 52 
0398+  FCB6 52 4F 52 3A 
0398+  FCBA 24 
0399+  FCBB 20 41 46 3D STR_AF		.DB	" AF=$"
0399+  FCBF 24 
0400+  FCC0 20 42 43 3D STR_BC		.DB	" BC=$"
0400+  FCC4 24 
0401+  FCC5 20 44 45 3D STR_DE		.DB	" DE=$"
0401+  FCC9 24 
0402+  FCCA 20 48 4C 3D STR_HL		.DB	" HL=$"
0402+  FCCE 24 
0403+  FCCF 20 50 43 3D STR_PC		.DB	" PC=$"
0403+  FCD3 24 
0404+  FCD4 20 53 50 3D STR_SP		.DB	" SP=$"
0404+  FCD8 24 
0405+  FCD9             ;
0406+  FCD9             ; INDIRECT JUMP TO ADDRESS IN HL
0407+  FCD9             ;
0408+  FCD9             ;   MOSTLY USEFUL TO PERFORM AN INDIRECT CALL LIKE:
0409+  FCD9             ;     LD	HL,xxxx
0410+  FCD9             ;     CALL	JPHL
0411+  FCD9             ;
0412+  FCD9 E9          JPHL:	JP	(HL)
0413+  FCDA             ;
0414+  FCDA             ; DELAY ABOUT 25us (100 TSTATES INCLUDING CALL AND RET)
0415+  FCDA             ;
0416+  FCDA             ;	TOTAL T STATES = ((B*13) + 51)
0417+  FCDA             ;	4MHZ CPU, B=4, 103 T STATES = 25.75us
0418+  FCDA             ;	8MHZ CPU, B=12, 207 TSTATES = 25.875us
0419+  FCDA             ;	B = ((2 * FREQ) - 4)
0420+  FCDA             ;
0421+  FCDA             DELAY:					; 17 T STATES (FOR CALL)
0422+  FCDA C5          	PUSH	BC			; 11 T STATES
0423+  FCDB 06 0C       	LD	B,((CPUFREQ * 2)  - 4)	; 8 T STATES
0424+  FCDD 10 FE       	DJNZ	$			; (B*13) - 5 T STATES
0425+  FCDF C1          	POP	BC			; 10 T STATES
0426+  FCE0 C9          	RET				; 10 T STATES
0427+  FCE1             ;
0428+  FCE1             ; DELAY 25us * VALUE IN DE (VARIABLE DELAY)
0429+  FCE1             ;
0430+  FCE1             VDELAY:
0431+  FCE1 CD DA FC    	CALL	DELAY
0432+  FCE4 1B          	DEC	DE
0433+  FCE5 7A          	LD	A,D
0434+  FCE6 B3          	OR	E
0435+  FCE7 C2 E1 FC    	JP	NZ,VDELAY
0436+  FCEA C9          	RET
0437+  FCEB             ;
0438+  FCEB             ; DELAY ABOUT 0.5 SECONDS = 25us * 20,000
0439+  FCEB             ;
0440+  FCEB             LDELAY:
0441+  FCEB D5          	PUSH	DE
0442+  FCEC 11 20 4E    	LD	DE,20000
0443+  FCEF CD E1 FC    	CALL	VDELAY
0444+  FCF2 D1          	POP	DE
0445+  FCF3 C9          	RET
0446+  FCF4             ;
0447+  FCF4             ; MULTIPLY 8-BIT VALUES
0448+  FCF4             ; IN:  MULTIPLY H BY E
0449+  FCF4             ; OUT: HL = RESULT, E = 0, B = 0
0450+  FCF4             ;
0451+  FCF4             MULT8:
0452+  FCF4 16 00       	LD D,0
0453+  FCF6 6A          	LD L,D
0454+  FCF7 06 08       	LD B,8
0455+  FCF9             MULT8_LOOP:
0456+  FCF9 29          	ADD HL,HL
0457+  FCFA 30 01       	JR NC,MULT8_NOADD
0458+  FCFC 19          	ADD HL,DE
0459+  FCFD             MULT8_NOADD:
0460+  FCFD 10 FA       	DJNZ MULT8_LOOP
0461+  FCFF C9          	RET
0462+  FD00             ;
0463+  FD00             ; PRINT VALUE OF HL IN DECIMAL WITH LEADING ZERO SUPPRESSION
0464+  FD00             ;
0465+  FD00             PRTDEC:
0466+  FD00 1E 30       	LD	E,'0'
0467+  FD02 01 F0 D8    	LD	BC,-10000
0468+  FD05 CD 1D FD    	CALL	PRTDEC1
0469+  FD08 01 18 FC    	LD	BC,-1000
0470+  FD0B CD 1D FD    	CALL	PRTDEC1
0471+  FD0E 01 9C FF    	LD	BC,-100
0472+  FD11 CD 1D FD    	CALL	PRTDEC1
0473+  FD14 0E F6       	LD	C,-10
0474+  FD16 CD 1D FD    	CALL	PRTDEC1
0475+  FD19 1E 00       	LD	E,0
0476+  FD1B 0E FF       	LD	C,-1
0477+  FD1D             PRTDEC1:
0478+  FD1D 3E 2F       	LD	A,'0' - 1
0479+  FD1F             PRTDEC2:
0480+  FD1F 3C          	INC	A
0481+  FD20 09          	ADD	HL,BC
0482+  FD21 38 FC       	JR	C,PRTDEC2
0483+  FD23 ED 42       	SBC	HL,BC
0484+  FD25 BB          	CP	E
0485+  FD26 C8          	RET	Z
0486+  FD27 1E 00       	LD	E,0
0487+  FD29 CD 72 FC    	CALL	COUT
0488+  FD2C C9          	RET
0489+  FD2D             ;
0490+  FD2D             ;==================================================================================================
0491+  FD2D             ; DSKY KEYBOARD ROUTINES
0492+  FD2D             ;==================================================================================================
0493+  FD2D             ;
0494+  FD2D~            #IF (DSKYENABLE)
0495+  FD2D~            ;
0496+  FD2D~            ;    _____C0______C1______C2______C3__
0497+  FD2D~            ;B5 |	$20 D	$60 E	$A0 F	$E0 BO
0498+  FD2D~            ;B4 |	$10 A	$50 B	$90 C	$D0 GO
0499+  FD2D~            ;B3 |	$08 7	$48 8	$88 9	$C8 EX
0500+  FD2D~            ;B2 |	$04 4	$44 5	$84 6	$C4 DE
0501+  FD2D~            ;B1 |	$02 1	$42 2	$82 3	$C2 EN
0502+  FD2D~            ;B0 |	$01 FW	$41 0	$81 BK	$C1 CL
0503+  FD2D~            ;
0504+  FD2D~            KY_0	.EQU	000H
0505+  FD2D~            KY_1	.EQU	001H
0506+  FD2D~            KY_2	.EQU	002H
0507+  FD2D~            KY_3	.EQU	003H
0508+  FD2D~            KY_4	.EQU	004H
0509+  FD2D~            KY_5	.EQU	005H
0510+  FD2D~            KY_6	.EQU	006H
0511+  FD2D~            KY_7	.EQU	007H
0512+  FD2D~            KY_8	.EQU	008H
0513+  FD2D~            KY_9	.EQU	009H
0514+  FD2D~            KY_A	.EQU	00AH
0515+  FD2D~            KY_B	.EQU	00BH
0516+  FD2D~            KY_C	.EQU	00CH
0517+  FD2D~            KY_D	.EQU	00DH
0518+  FD2D~            KY_E	.EQU	00EH
0519+  FD2D~            KY_F	.EQU	00FH
0520+  FD2D~            KY_FW	.EQU	010H	; FORWARD
0521+  FD2D~            KY_BK	.EQU	011H	; BACKWARD
0522+  FD2D~            KY_CL	.EQU	012H	; CLEAR
0523+  FD2D~            KY_EN	.EQU	013H	; ENTER
0524+  FD2D~            KY_DE	.EQU	014H	; DEPOSIT
0525+  FD2D~            KY_EX	.EQU	015H	; EXAMINE
0526+  FD2D~            KY_GO	.EQU	016H	; GO
0527+  FD2D~            KY_BO	.EQU	017H	; BOOT
0528+  FD2D~            ;
0529+  FD2D~            ;__DSKY_INIT_________________________________________________________________________________________
0530+  FD2D~            ;
0531+  FD2D~            ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
0532+  FD2D~            ;____________________________________________________________________________________________________
0533+  FD2D~            ;
0534+  FD2D~            DSKY_INIT:
0535+  FD2D~            	LD	A,82H
0536+  FD2D~            	OUT 	(PPIX),A
0537+  FD2D~            	LD	A,30H			;disable /CS on PPISD card(s)
0538+  FD2D~            	OUT	(PPIC),A
0539+  FD2D~            	XOR	A
0540+  FD2D~            	LD	(KY_BUF),A
0541+  FD2D~            	RET
0542+  FD2D~            #IFDEF DSKY_KBD
0543+  FD2D~            ;
0544+  FD2D~            ;__KY_STAT___________________________________________________________________________________________
0545+  FD2D~            ;
0546+  FD2D~            ;  CHECK FOR KEY PRESS, SAVE RAW VALUE, RETURN STATUS
0547+  FD2D~            ;____________________________________________________________________________________________________
0548+  FD2D~            ;
0549+  FD2D~            KY_STAT:
0550+  FD2D~            	; IF WE ALREADY HAVE A KEY, RETURN WITH NZ
0551+  FD2D~            	LD	A,(KY_BUF)
0552+  FD2D~            	OR	A
0553+  FD2D~            	RET	NZ
0554+  FD2D~            	; SCAN FOR A KEYPRESS, A=0 NO DATA OR A=RAW BYTE
0555+  FD2D~            	CALL	KY_SCAN			; SCAN KB ONCE
0556+  FD2D~            	OR	A			; SET FLAGS
0557+  FD2D~            	RET	Z			; NOTHING FOUND, GET OUT
0558+  FD2D~            	LD	(KY_BUF),A		; SAVE RAW KEYCODE
0559+  FD2D~            	RET				; RETURN
0560+  FD2D~            ;
0561+  FD2D~            ;__KY_GET____________________________________________________________________________________________
0562+  FD2D~            ;
0563+  FD2D~            ;  GET A SINGLE KEY (WAIT FOR ONE IF NECESSARY)
0564+  FD2D~            ;____________________________________________________________________________________________________
0565+  FD2D~            ;
0566+  FD2D~            KY_GET:
0567+  FD2D~            	; SEE IF WE ALREADY HAVE A KEY SAVED, GO TO DECODE IF SO
0568+  FD2D~            	LD	A,(KY_BUF)
0569+  FD2D~            	OR	A
0570+  FD2D~            	JR	NZ,KY_DECODE
0571+  FD2D~            	; NO KEY SAVED, WAIT FOR ONE
0572+  FD2D~            KY_STATLOOP:
0573+  FD2D~            	CALL	KY_STAT
0574+  FD2D~            	OR	A
0575+  FD2D~            	JR	Z,KY_STATLOOP
0576+  FD2D~            	; DECODE THE RAW VALUE
0577+  FD2D~            KY_DECODE:
0578+  FD2D~            	LD	D,00H
0579+  FD2D~            	LD	HL,KY_KEYMAP		; POINT TO BEGINNING OF TABLE	
0580+  FD2D~            KY_GET_LOOP:
0581+  FD2D~            	CP	(HL)			; MATCH?
0582+  FD2D~            	JR	Z,KY_GET_DONE		; FOUND, DONE
0583+  FD2D~            	INC	HL
0584+  FD2D~            	INC	D			; D + 1
0585+  FD2D~            	JR	NZ,KY_GET_LOOP		; NOT FOUND, LOOP UNTIL EOT			
0586+  FD2D~            KY_GET_DONE:
0587+  FD2D~            	; CLEAR OUT KEY_BUF
0588+  FD2D~            	XOR	A
0589+  FD2D~            	LD	(KY_BUF),A
0590+  FD2D~            	; RETURN THE INDEX POSITION WHERE THE RAW VALUE WAS FOUND
0591+  FD2D~            	LD	A,D
0592+  FD2D~            	RET
0593+  FD2D~            ;	
0594+  FD2D~            ;__KY_SCAN____________________________________________________________________________________________
0595+  FD2D~            ;
0596+  FD2D~            ;  SCAN KEYBOARD MATRIX FOR AN INPUT
0597+  FD2D~            ;____________________________________________________________________________________________________
0598+  FD2D~            ;
0599+  FD2D~            KY_SCAN:
0600+  FD2D~            	LD	C,0000H
0601+  FD2D~            	LD	A,41H | 30H		;  SCAN COL ONE
0602+  FD2D~            	OUT 	(PPIC),A		;  SEND TO COLUMN LINES
0603+  FD2D~            	CALL	DELAY			;  DEBOUNCE
0604+  FD2D~            	IN	A,(PPIB)		;  GET ROWS
0605+  FD2D~            	AND	7FH			;ignore PB7 for PPISD
0606+  FD2D~            	CP	00H 			;  ANYTHING PRESSED?
0607+  FD2D~            	JR	NZ,KY_SCAN_FOUND	;  YES, EXIT 
0608+  FD2D~            
0609+  FD2D~            	LD	C,0040H
0610+  FD2D~            	LD	A,42H | 30H		;  SCAN COL TWO
0611+  FD2D~            	OUT 	(PPIC),A		;  SEND TO COLUMN LINES
0612+  FD2D~            	CALL	DELAY			;  DEBOUNCE
0613+  FD2D~            	IN	A,(PPIB)		;  GET ROWS
0614+  FD2D~            	AND	7FH			;ignore PB7 for PPISD
0615+  FD2D~            	CP	00H 			;  ANYTHING PRESSED?
0616+  FD2D~            	JR	NZ,KY_SCAN_FOUND	;  YES, EXIT 
0617+  FD2D~            
0618+  FD2D~            	LD	C,0080H
0619+  FD2D~            	LD	A,44H | 30H		;  SCAN COL THREE
0620+  FD2D~            	OUT	(PPIC),A		;  SEND TO COLUMN LINES
0621+  FD2D~            	CALL	DELAY			;  DEBOUNCE
0622+  FD2D~            	IN	A,(PPIB)		;  GET ROWS
0623+  FD2D~            	AND	7FH			;ignore PB7 for PPISD
0624+  FD2D~            	CP	00H 			;  ANYTHING PRESSED?
0625+  FD2D~            	JR	NZ,KY_SCAN_FOUND	;  YES, EXIT 
0626+  FD2D~            
0627+  FD2D~            	LD	C,00C0H			;
0628+  FD2D~            	LD	A,48H | 30H		;  SCAN COL FOUR
0629+  FD2D~            	OUT	(PPIC),A		;  SEND TO COLUMN LINES
0630+  FD2D~            	CALL	DELAY			;  DEBOUNCE
0631+  FD2D~            	IN	A,(PPIB)		;  GET ROWS
0632+  FD2D~            	AND	7FH			;ignore PB7 for PPISD
0633+  FD2D~            	CP	00H 			;  ANYTHING PRESSED?
0634+  FD2D~            	JR	NZ,KY_SCAN_FOUND	;  YES, EXIT 
0635+  FD2D~            
0636+  FD2D~            	LD	A,040H | 30H		;  TURN OFF ALL COLUMNS
0637+  FD2D~            	OUT	(PPIC),A		;  SEND TO COLUMN LINES
0638+  FD2D~            	LD	A,00H			;  RETURN NULL
0639+  FD2D~            	RET				;  EXIT
0640+  FD2D~            
0641+  FD2D~            KY_SCAN_FOUND:
0642+  FD2D~            	AND	3FH			;  CLEAR TOP TWO BITS
0643+  FD2D~            	OR	C			;  ADD IN ROW BITS 
0644+  FD2D~            	LD	C,A			;  STORE VALUE
0645+  FD2D~            
0646+  FD2D~            	; WAIT FOR KEY TO BE RELEASED
0647+  FD2D~            	LD	A,4FH | 30H		; SCAN ALL COL LINES
0648+  FD2D~            	OUT	(PPIC),A		; SEND TO COLUMN LINES
0649+  FD2D~            	CALL	DELAY			; DEBOUNCE
0650+  FD2D~            KY_CLEAR_LOOP:				; WAIT FOR KEY TO CLEAR
0651+  FD2D~            	IN	A,(PPIB)		; GET ROWS
0652+  FD2D~            	AND	7FH			;ignore PB7 for PPISD
0653+  FD2D~            	CP	00H 			; ANYTHING PRESSED?
0654+  FD2D~            	JR	NZ,KY_CLEAR_LOOP	; YES, LOOP UNTIL KEY RELEASED
0655+  FD2D~            
0656+  FD2D~            	LD	A,040H | 30H		;  TURN OFF ALL COLUMNS
0657+  FD2D~            	OUT 	(PPIC),A		;  SEND TO COLUMN LINES
0658+  FD2D~            
0659+  FD2D~            	LD	A,C			;  RESTORE VALUE
0660+  FD2D~            	RET
0661+  FD2D~            ;
0662+  FD2D~            ;_KEYMAP_TABLE_____________________________________________________________________________________________________________
0663+  FD2D~            ; 
0664+  FD2D~            KY_KEYMAP:
0665+  FD2D~            ;               0    1    2    3    4    5    6    7
0666+  FD2D~            	.DB	041H,002H,042H,082H,004H,044H,084H,008H
0667+  FD2D~            ;               8    9    A    B    C    D    E    F
0668+  FD2D~            	.DB	048H,088H,010H,050H,090H,020H,060H,0A0H
0669+  FD2D~            ;               FW   BK   CL   EN   DE   EX   GO   BO
0670+  FD2D~            	.DB	001H,081H,0C1H,0C2H,0C4H,0C8H,0D0H,0E0H
0671+  FD2D~            #ENDIF	; DSKY_KBD
0672+  FD2D~            ;
0673+  FD2D~            ;==================================================================================================
0674+  FD2D~            ; DSKY HEX DISPLAY
0675+  FD2D~            ;==================================================================================================
0676+  FD2D~            ;
0677+  FD2D~            DSKY_HEXOUT:
0678+  FD2D~            	LD	B,DSKY_HEXBUFLEN
0679+  FD2D~            	LD	HL,DSKY_BUF
0680+  FD2D~            	LD	DE,DSKY_HEXBUF
0681+  FD2D~            DSKY_HEXOUT1:
0682+  FD2D~            	LD	A,(DE)		; FIRST NIBBLE
0683+  FD2D~            	SRL	A
0684+  FD2D~            	SRL	A
0685+  FD2D~            	SRL	A
0686+  FD2D~            	SRL	A
0687+  FD2D~            	LD	(HL),A
0688+  FD2D~            	INC	HL
0689+  FD2D~            	LD	A,(DE)		; SECOND NIBBLE
0690+  FD2D~            	AND	0FH
0691+  FD2D~            	LD	(HL),A
0692+  FD2D~            	INC	HL
0693+  FD2D~            	INC	DE		; NEXT BYTE
0694+  FD2D~            	DJNZ	DSKY_HEXOUT1
0695+  FD2D~            
0696+  FD2D~            	LD	A,82H			; SETUP PPI
0697+  FD2D~            	OUT	(PPIX),A
0698+  FD2D~            	CALL	DSKY_COFF
0699+  FD2D~            	LD	A,0D0H			; 7218 -> (DATA COMING, HEXA DECODE)
0700+  FD2D~            	OUT	(PPIA),A
0701+  FD2D~            	CALL	DSKY_STROBEC
0702+  FD2D~            
0703+  FD2D~            	LD	HL,DSKY_BUF		; POINT TO START OF BUF
0704+  FD2D~            	LD	B,DSKY_BUFLEN		; NUMBER OF DIGITS
0705+  FD2D~            	LD	C,PPIA
0706+  FD2D~            DSKY_HEXOUT2:
0707+  FD2D~            	OUTI
0708+  FD2D~            	JP	Z,DSKY_STROBE		; DO FINAL STROBE AND RETURN
0709+  FD2D~            	CALL	DSKY_STROBE
0710+  FD2D~            	JR	DSKY_HEXOUT2
0711+  FD2D~            	
0712+  FD2D~            DSKY_STROBEC:
0713+  FD2D~            	LD	A,80H | 30H
0714+  FD2D~            	JP	DSKY_STROBE0
0715+  FD2D~            
0716+  FD2D~            DSKY_STROBE:
0717+  FD2D~            	LD	A,00H | 30H		; SET WRITE STROBE
0718+  FD2D~            
0719+  FD2D~            DSKY_STROBE0:
0720+  FD2D~            	OUT	(PPIC),A		; OUT TO PORTC
0721+  FD2D~            	CALL	DELAY			; DELAY
0722+  FD2D~            DSKY_COFF
0723+  FD2D~            	LD	A,40H | 30H		; SET CONTROL PORT OFF
0724+  FD2D~            	OUT	(PPIC),A		; OUT TO PORTC
0725+  FD2D~            	CALL	DELAY			; WAIT
0726+  FD2D~            	RET
0727+  FD2D             #ENDIF
0728+  FD2D             ;
0729+  FD2D             ;==================================================================================================
0730+  FD2D             ; DATA
0731+  FD2D             ;==================================================================================================
0732+  FD2D             ;
0733+  FD2D 3C 45 4D 50 STR_EMPTY	.TEXT	"<EMPTY>$"
0733+  FD31 54 59 3E 24 
0734+  FD35             ;
0735+  FD35 00          KY_BUF		.DB	0
0736+  FD36 00 00 00 00 DSKY_BUF:	.FILL	8,0
0736+  FD3A 00 00 00 00 
0737+  FD3E             DSKY_BUFLEN	.EQU	$ - DSKY_BUF
0738+  FD3E 00 00 00 00 DSKY_HEXBUF	.FILL	4,0
0739+  FD42             DSKY_HEXBUFLEN	.EQU	$ - DSKY_HEXBUF
0359   FD42             ;
0360   FD42             ;==================================================================================================
0361   FD42             ;   BANK ONE GLOBAL DATA
0362   FD42             ;==================================================================================================
0363   FD42             ;
0364   FD42 00          CONDEV		.DB	DEFCON
0365   FD43             ;
0366   FD43 00          IDLECOUNT	.DB	0
0367   FD44             ;
0368   FD44 00          HSTDSK		.DB	0		; DISK IN BUFFER
0369   FD45 00 00       HSTTRK		.DW	0		; TRACK IN BUFFER
0370   FD47 00 00       HSTSEC		.DW	0		; SECTOR IN BUFFER
0371   FD49             ;
0372   FD49             ;DIOBUF		.DW	$FD00		; PTR TO 512 BYTE DISK XFR BUFFER
0373   FD49 00 80       DIOBUF		.DW	$8000		; PTR TO 512 BYTE DISK XFR BUFFER
0374   FD4B             ;
0375   FD4B 53 32 49 20 STR_BANNER	.DB	"S2I HBIOS v", BIOSVER, " ("
0375   FD4F 48 42 49 4F 
0375   FD53 53 20 76 32 
0375   FD57 2E 32 20 42 
0375   FD5B 33 20 28 
0376   FD5E 53 32 49 2D VAR_LOC		.DB	VARIANT, "-"
0376   FD62 57 61 79 6E 
0376   FD66 65 2D 
0377   FD68 32 31 30 34 TST_LOC		.DB	TIMESTAMP, ")$"
0377   FD6C 30 32 54 30 
0377   FD70 37 32 33 29 
0377   FD74 24 
0378   FD75 53 43 53 49 STR_PLATFORM	.DB	PLATFORM_NAME, "$"
0378   FD79 32 49 44 45 
0378   FD7D 20 5A 38 30 
0378   FD81 24 
0379   FD82             ;
0380   FD82             ;==================================================================================================
0381   FD82             ;   FILL REMAINDER OF BANK
0382   FD82             ;==================================================================================================
0383   FD82             ;
0384   FD82             SLACK:		.EQU	($FF00 - $)
0385   FD82 FF FF FF FF 		.FILL	SLACK,0FFH
0385   FD86 FF FF FF FF 
0385   FD8A FF FF FF FF 
0385   FD8E FF FF FF FF 
0385   FD92 FF FF FF FF 
0385   FD96 FF FF FF FF 
0385   FD9A FF FF FF FF 
0385   FD9E FF FF FF FF 
0385   FDA2 FF FF FF FF 
0385   FDA6 FF FF FF FF 
0385   FDAA FF FF FF FF 
0385   FDAE FF FF FF FF 
0385   FDB2 FF FF FF FF 
0385   FDB6 FF FF FF FF 
0385   FDBA FF FF FF FF 
0385   FDBE FF FF FF FF 
0385   FDC2 FF FF FF FF 
0385   FDC6 FF FF FF FF 
0385   FDCA FF FF FF FF 
0385   FDCE FF FF FF FF 
0385   FDD2 FF FF FF FF 
0385   FDD6 FF FF FF FF 
0385   FDDA FF FF FF FF 
0385   FDDE FF FF FF FF 
0385   FDE2 FF FF FF FF 
0385   FDE6 FF FF FF FF 
0385   FDEA FF FF FF FF 
0385   FDEE FF FF FF FF 
0385   FDF2 FF FF FF FF 
0385   FDF6 FF FF FF FF 
0385   FDFA FF FF FF FF 
0385   FDFE FF FF FF FF 
0385   FE02 FF FF FF FF 
0385   FE06 FF FF FF FF 
0385   FE0A FF FF FF FF 
0385   FE0E FF FF FF FF 
0385   FE12 FF FF FF FF 
0385   FE16 FF FF FF FF 
0385   FE1A FF FF FF FF 
0385   FE1E FF FF FF FF 
0385   FE22 FF FF FF FF 
0385   FE26 FF FF FF FF 
0385   FE2A FF FF FF FF 
0385   FE2E FF FF FF FF 
0385   FE32 FF FF FF FF 
0385   FE36 FF FF FF FF 
0385   FE3A FF FF FF FF 
0385   FE3E FF FF FF FF 
0385   FE42 FF FF FF FF 
0385   FE46 FF FF FF FF 
0385   FE4A FF FF FF FF 
0385   FE4E FF FF FF FF 
0385   FE52 FF FF FF FF 
0385   FE56 FF FF FF FF 
0385   FE5A FF FF FF FF 
0385   FE5E FF FF FF FF 
0385   FE62 FF FF FF FF 
0385   FE66 FF FF FF FF 
0385   FE6A FF FF FF FF 
0385   FE6E FF FF FF FF 
0385   FE72 FF FF FF FF 
0385   FE76 FF FF FF FF 
0385   FE7A FF FF FF FF 
0385   FE7E FF FF FF FF 
0385   FE82 FF FF FF FF 
0385   FE86 FF FF FF FF 
0385   FE8A FF FF FF FF 
0385   FE8E FF FF FF FF 
0385   FE92 FF FF FF FF 
0385   FE96 FF FF FF FF 
0385   FE9A FF FF FF FF 
0385   FE9E FF FF FF FF 
0385   FEA2 FF FF FF FF 
0385   FEA6 FF FF FF FF 
0385   FEAA FF FF FF FF 
0385   FEAE FF FF FF FF 
0385   FEB2 FF FF FF FF 
0385   FEB6 FF FF FF FF 
0385   FEBA FF FF FF FF 
0385   FEBE FF FF FF FF 
0385   FEC2 FF FF FF FF 
0385   FEC6 FF FF FF FF 
0385   FECA FF FF FF FF 
0385   FECE FF FF FF FF 
0385   FED2 FF FF FF FF 
0385   FED6 FF FF FF FF 
0385   FEDA FF FF FF FF 
0385   FEDE FF FF FF FF 
0385   FEE2 FF FF FF FF 
0385   FEE6 FF FF FF FF 
0385   FEEA FF FF FF FF 
0385   FEEE FF FF FF FF 
0385   FEF2 FF FF FF FF 
0385   FEF6 FF FF FF FF 
0385   FEFA FF FF FF FF 
0385   FEFE FF FF 
0386   FF00             ;
0387   FF00             		.ECHO	"HBIOS space remaining: "
0388   FF00             		.ECHO	SLACK
0389   FF00             		.ECHO	" bytes.\n"
0390   FF00             ;
0391   FF00             ;==================================================================================================
0392   FF00             ;   HBIOS UPPER MEMORY STUB
0393   FF00             ;==================================================================================================
0394   FF00             ;
0395   FF00             ;==================================================================================================
0396   FF00             ;   HBIOS INTERRUPT VECTOR TABLE
0397   FF00             ;==================================================================================================
0398   FF00             ;
0399   FF00             ; AREA RESERVED FOR UP TO 16 INTERRUPT VECTOR ENTRIES (MODE 2)
0400   FF00             ;
0401   FF00             HB_IVT:
0402   FF00 FF FF FF FF 	.FILL	20H,0FFH
0402   FF04 FF FF FF FF 
0402   FF08 FF FF FF FF 
0402   FF0C FF FF FF FF 
0402   FF10 FF FF FF FF 
0402   FF14 FF FF FF FF 
0402   FF18 FF FF FF FF 
0402   FF1C FF FF FF FF 
0403   FF20             ;
0404   FF20             ;==================================================================================================
0405   FF20             ;   HBIOS ENTRY FOR RST 08 PROCESSING
0406   FF20             ;==================================================================================================
0407   FF20             ;
0408   FF20             ; ENTRY POINT FOR BIOS FUNCTIONS (TARGET OF RST 08)
0409   FF20             ;
0410   FF20             HB_ENTRY:
0411   FF20 CD 78 F0    	CALL	BIOS_DISPATCH	; CALL HBIOS FUNCTION DISPATCHER
0412   FF23 C9          	RET			; RETURN TO CALLER
0413   FF24             ;
0414   FF24             HB_SLACK	.EQU	($FFFF - $ + 1)
0415   FF24             		.ECHO	"STACK space remaining: "
0416   FF24             		.ECHO	HB_SLACK
0417   FF24             		.ECHO	" bytes.\n"
0418   FF24             ;
0419   FF24 FF FF FF FF 		.FILL	HB_SLACK,0FFH
0419   FF28 FF FF FF FF 
0419   FF2C FF FF FF FF 
0419   FF30 FF FF FF FF 
0419   FF34 FF FF FF FF 
0419   FF38 FF FF FF FF 
0419   FF3C FF FF FF FF 
0419   FF40 FF FF FF FF 
0419   FF44 FF FF FF FF 
0419   FF48 FF FF FF FF 
0419   FF4C FF FF FF FF 
0419   FF50 FF FF FF FF 
0419   FF54 FF FF FF FF 
0419   FF58 FF FF FF FF 
0419   FF5C FF FF FF FF 
0419   FF60 FF FF FF FF 
0419   FF64 FF FF FF FF 
0419   FF68 FF FF FF FF 
0419   FF6C FF FF FF FF 
0419   FF70 FF FF FF FF 
0419   FF74 FF FF FF FF 
0419   FF78 FF FF FF FF 
0419   FF7C FF FF FF FF 
0419   FF80 FF FF FF FF 
0419   FF84 FF FF FF FF 
0419   FF88 FF FF FF FF 
0419   FF8C FF FF FF FF 
0419   FF90 FF FF FF FF 
0419   FF94 FF FF FF FF 
0419   FF98 FF FF FF FF 
0419   FF9C FF FF FF FF 
0419   FFA0 FF FF FF FF 
0419   FFA4 FF FF FF FF 
0419   FFA8 FF FF FF FF 
0419   FFAC FF FF FF FF 
0419   FFB0 FF FF FF FF 
0419   FFB4 FF FF FF FF 
0419   FFB8 FF FF FF FF 
0419   FFBC FF FF FF FF 
0419   FFC0 FF FF FF FF 
0419   FFC4 FF FF FF FF 
0419   FFC8 FF FF FF FF 
0419   FFCC FF FF FF FF 
0419   FFD0 FF FF FF FF 
0419   FFD4 FF FF FF FF 
0419   FFD8 FF FF FF FF 
0419   FFDC FF FF FF FF 
0419   FFE0 FF FF FF FF 
0419   FFE4 FF FF FF FF 
0419   FFE8 FF FF FF FF 
0419   FFEC FF FF FF FF 
0419   FFF0 FF FF FF FF 
0419   FFF4 FF FF FF FF 
0419   FFF8 FF FF FF FF 
0419   FFFC FF FF FF FF 
0420   10000             		.END
tasm: Number of errors = 0
